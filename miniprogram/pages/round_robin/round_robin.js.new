// è·å–åº”ç”¨å®ä¾‹
const app = getApp();

Page({
  /**
   * é¡µé¢çš„åˆå§‹æ•°æ?   */
  data: {
    mode: 'singles', // é»˜è®¤ä¸ºå•æ‰“æ¨¡å¼?    tournamentType: 'round_robin', // æ¯”èµ›ç±»å‹ï¼šround_robin(å®Œå…¨å¾ªç¯)æˆ–swiss(ç‘å£«è½?
    players: [], // æ‰€æœ‰å¯é€‰æ‹©çš„é€‰æ‰‹
    selectedPlayers: [], // å·²é€‰æ‹©çš„é€‰æ‰‹
    matchTable: [], // æ¯”èµ›è¡¨æ ¼æ•°æ®
    showPlayerSelectModal: false, // æ˜¯å¦æ˜¾ç¤ºé€‰æ‰‹é€‰æ‹©å¼¹çª—
    isMatchStarted: false, // æ¯”èµ›æ˜¯å¦å·²å¼€å§?    isMatchEnded: false, // æ¯”èµ›æ˜¯å¦å·²ç»“æ?    currentRound: 1, // å½“å‰è½®æ¬¡ï¼ˆç‘å£«è½®ä½¿ç”¨ï¼?    totalRounds: 0, // æ€»è½®æ¬¡ï¼ˆç‘å£«è½®ä½¿ç”¨ï¼‰
    playerRankings: [], // é€‰æ‰‹æ’åï¼ˆç‘å£«è½®ä½¿ç”¨ï¼?    showAddTempPlayerModal: false, // æ˜¯å¦æ˜¾ç¤ºæ·»åŠ ä¸´æ—¶é€‰æ‰‹å¼¹çª—
    tempPlayerName: '', // ä¸´æ—¶é€‰æ‰‹å§“å
    tempPlayerGender: 'male', // ä¸´æ—¶é€‰æ‰‹æ€§åˆ«ï¼Œé»˜è®¤ä¸ºç”?    isDoubles: false, // æ˜¯å¦ä¸ºåŒæ‰“æ¨¡å¼?    showScoreInputModal: false,
    currentMatch: null,
    teamScore: '',
    opponentScore: '',
    activeScoreInput: 'team', // å½“å‰æ¿€æ´»çš„åˆ†æ•°è¾“å…¥æ¡†ï¼Œå¯é€‰å€¼ï¼š'team'æˆ?opponent'
    showRankingModal: false, // æ˜¯å¦æ˜¾ç¤ºæ’åç»“æœå¼¹çª—
  },

  /**
   * ç”Ÿå‘½å‘¨æœŸå‡½æ•°--ç›‘å¬é¡µé¢åŠ è½½
   */
  onLoad: function (options) {
    const mode = options.mode || 'singles';
    const tournamentType = options.tournament_type || 'round_robin';
    
    this.setData({
      mode: mode,
      tournamentType: tournamentType,
      isDoubles: mode === 'doubles'
    });
    
    // åŠ è½½é€‰æ‰‹æ•°æ®
    this.loadPlayers();
    
    // æ£€æŸ¥æ˜¯å¦æœ‰è¿›è¡Œä¸­çš„æ¯”èµ›
    this.checkOngoingMatch();
  },
  
  /**
   * åŠ è½½é€‰æ‰‹æ•°æ®
   */
  loadPlayers: function() {
    const allPlayers = app.globalData.players || [];
    
    this.setData({
      players: allPlayers
    });
  },
  
  /**
   * æ£€æŸ¥æ˜¯å¦æœ‰è¿›è¡Œä¸­çš„æ¯”èµ›
   */
  checkOngoingMatch: function() {
    const storageKey = this.data.tournamentType === 'swiss' ? 'ongoingSwissMatch' : 'ongoingRoundRobinMatch';
    const ongoingMatch = wx.getStorageSync(storageKey);
    
    if (ongoingMatch && ongoingMatch.mode === this.data.mode) {
      this.setData({
        selectedPlayers: ongoingMatch.players,
        matchTable: ongoingMatch.matchTable,
        isMatchStarted: true,
        currentRound: ongoingMatch.currentRound || 1,
        totalRounds: ongoingMatch.totalRounds || 0,
        playerRankings: ongoingMatch.playerRankings || []
      });
    }
  },
  
  /**
   * æ˜¾ç¤ºé€‰æ‰‹é€‰æ‹©å¼¹çª—
   */
  showPlayerSelect: function() {
    this.setData({
      showPlayerSelectModal: true
    });
  },
  
  /**
   * éšè—é€‰æ‰‹é€‰æ‹©å¼¹çª—
   */
  hidePlayerSelect: function() {
    this.setData({
      showPlayerSelectModal: false
    });
  },
  
  /**
   * åˆ‡æ¢é€‰æ‰‹é€‰æ‹©çŠ¶æ€?   */
  togglePlayerSelection: function(e) {
    const playerId = e.currentTarget.dataset.id;
    const { selectedPlayers, isDoubles, players } = this.data;
    
    // æŸ¥æ‰¾é€‰æ‰‹å¯¹è±¡
    const player = players.find(p => p.id === playerId);
    if (!player) return;
    
    // æŸ¥æ‰¾é€‰æ‰‹æ˜¯å¦å·²è¢«é€‰ä¸­
    const index = selectedPlayers.findIndex(p => p.id === playerId);
    
    // å¦‚æœæ˜¯åŒæ‰“æ¨¡å¼?    if (isDoubles) {
      // å¦‚æœå·²ç»é€‰æ‹©äº?åé€‰æ‰‹ï¼Œä¸”å½“å‰é€‰æ‰‹æœªè¢«é€‰ä¸­ï¼Œåˆ™ä¸å…è®¸å†é€?      if (selectedPlayers.length >= 4 && index === -1) {
        wx.showToast({
          title: 'åŒæ‰“æ¨¡å¼æœ€å¤šé€‰æ‹©4åé€‰æ‰‹',
          icon: 'none'
        });
        return;
      }
      
      // åˆ‡æ¢é€‰æ‹©çŠ¶æ€?      let newSelectedPlayers = [...selectedPlayers];
      if (index !== -1) {
        // å–æ¶ˆé€‰æ‹©
        newSelectedPlayers.splice(index, 1);
      } else {
        // æ·»åŠ é€‰æ‹©
        newSelectedPlayers.push(player);
      }
      
      this.setData({
        selectedPlayers: newSelectedPlayers
      });
    } else {
      // å•æ‰“æ¨¡å¼ - ç§»é™¤é€‰æ‰‹æ•°é‡é™åˆ¶
      // åˆ‡æ¢é€‰æ‹©çŠ¶æ€?      let newSelectedPlayers = [...selectedPlayers];
      if (index !== -1) {
        // å–æ¶ˆé€‰æ‹©
        newSelectedPlayers.splice(index, 1);
      } else {
        // æ·»åŠ é€‰æ‹©
        newSelectedPlayers.push(player);
      }
      
      this.setData({
        selectedPlayers: newSelectedPlayers
      });
    }
  },
  
  /**
   * æ£€æŸ¥é€‰æ‰‹æ˜¯å¦è¢«é€‰ä¸­
   */
  isPlayerSelected: function(playerId) {
    return this.data.selectedPlayers.some(function(player) {
      return player.id === playerId;
    });
  },
  
  /**
   * ç¡®è®¤é€‰æ‰‹é€‰æ‹©
   */
  confirmPlayerSelection: function() {
    const { selectedPlayers, mode, tournamentType } = this.data;
    
    // æ£€æŸ¥é€‰æ‰‹æ•°é‡
    if (selectedPlayers.length < 2) {
      wx.showToast({
        title: 'è‡³å°‘éœ€è¦?åé€‰æ‰‹',
        icon: 'none'
      });
      return;
    }
    
    // å¦‚æœæ˜¯åŒæ‰“æ¨¡å¼ï¼Œæ£€æŸ¥é€‰æ‰‹æ•°é‡æ˜¯å¦ä¸ºå¶æ•?    if (mode === 'doubles' && selectedPlayers.length % 2 !== 0) {
      wx.showToast({
        title: 'åŒæ‰“æ¨¡å¼éœ€è¦å¶æ•°åé€‰æ‰‹',
        icon: 'none'
      });
      return;
    }

    // å¦‚æœæ˜¯åŒæ‰“æ¨¡å¼ï¼Œç»„ç»‡é€‰æ‰‹ä¸ºç»„å?    if (mode === 'doubles') {
      // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„ç”·å¥³é€‰æ‰‹ç»„æˆæ··åŒ
      const maleCount = selectedPlayers.filter(p => p.gender === 'male').length;
      const femaleCount = selectedPlayers.filter(p => p.gender === 'female').length;
      
      // æç¤ºæ€§åˆ«ç»„åˆæƒ…å†µ
      let pairsInfo = '';
      if (maleCount >= 2 && femaleCount >= 2) {
        pairsInfo = 'å°†ç»„æˆç”·åŒã€å¥³åŒå’Œæ··åŒç»„åˆ';
      } else if (maleCount >= 2) {
        pairsInfo = 'å°†ç»„æˆç”·åŒç»„å?;
      } else if (femaleCount >= 2) {
        pairsInfo = 'å°†ç»„æˆå¥³åŒç»„å?;
      } else if (maleCount > 0 && femaleCount > 0) {
        pairsInfo = 'å°†ç»„æˆæ··åŒç»„å?;
      }
      
      wx.showToast({
        title: pairsInfo,
        icon: 'none',
        duration: 2000
      });
    }
    
    // è®¡ç®—ç‘å£«è½®æ€»è½®æ¬¡ï¼ˆå¦‚æœæ˜¯ç‘å£«è½®ï¼?    if (tournamentType === 'swiss') {
      // ç‘å£«è½®é€šå¸¸ä¸ºlog2(n)å‘ä¸Šå–æ•´ï¼Œæœ€å¤šä¸è¶…è¿‡é€‰æ‰‹æ•°é‡-1
      const playerCount = mode === 'singles' ? selectedPlayers.length : selectedPlayers.length / 2;
      const totalRounds = Math.min(Math.ceil(Math.log2(playerCount)), playerCount - 1);
      
      this.setData({
        totalRounds: totalRounds
      });
      
      // åˆå§‹åŒ–é€‰æ‰‹æ’åï¼ˆæŒ‰ç…§åˆå§‹åˆ†æ•°æ’åºï¼‰
      const playerRankings = selectedPlayers.map(player => ({
        ...player,
        wins: 0,
        losses: 0,
        points: 0,
        opponents: []
      })).sort((a, b) => b.score - a.score);
      
      this.setData({
        playerRankings: playerRankings
      });
    }
    
    // ç”Ÿæˆæ¯”èµ›è¡¨æ ¼æ•°æ®
    this.generateMatchTable();
    
    this.setData({
      showPlayerSelectModal: false,
      isMatchStarted: true
    });
    
    // ä¿å­˜è¿›è¡Œä¸­çš„æ¯”èµ›
    this.saveOngoingMatch();
  },
  
  /**
   * ç”Ÿæˆæ¯”èµ›è¡¨æ ¼æ•°æ®
   */
  generateMatchTable: function() {
    const { selectedPlayers, mode, tournamentType, currentRound, playerRankings } = this.data;
    const matchTable = [];
    
    if (tournamentType === 'round_robin') {
      // å®Œå…¨å¾ªç¯èµ?    if (mode === 'singles') {
      // å•æ‰“æ¨¡å¼
      for (let i = 0; i < selectedPlayers.length; i++) {
        const row = {
          player: selectedPlayers[i],
          matches: []
        };
        
        for (let j = 0; j < selectedPlayers.length; j++) {
          if (i === j) {
            // è‡ªå·±å¯¹è‡ªå·±ï¼Œæ˜¾ç¤ºæ–œæ 
            row.matches.push({
              opponent: selectedPlayers[j],
              score: '/',
              isSelfMatch: true
            });
          } else {
            // æŸ¥æ‰¾æ˜¯å¦å·²æœ‰æ¯”èµ›è®°å½•
            const existingTable = this.data.matchTable || [];
            const existingRow = existingTable.find(r => r.player.id === selectedPlayers[i].id);
            const existingMatch = existingRow ? existingRow.matches.find(m => m.opponent.id === selectedPlayers[j].id) : null;
            
            row.matches.push({
              opponent: selectedPlayers[j],
              score: existingMatch ? existingMatch.score : '',
              id: `match_${selectedPlayers[i].id}_${selectedPlayers[j].id}`
            });
          }
        }
        
        matchTable.push(row);
      }
    } else {
      // åŒæ‰“æ¨¡å¼
      // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„åŒæ‰“ç»„åˆ
      const teams = [];
        
        // å…ˆå°†é€‰æ‰‹æŒ‰æ€§åˆ«åˆ†ç»„
        const malePlayers = selectedPlayers.filter(p => p.gender === 'male');
        const femalePlayers = selectedPlayers.filter(p => p.gender === 'female');
        
        // å°½å¯èƒ½ç»„æˆç”·å?        for (let i = 0; i < malePlayers.length - 1; i += 2) {
          if (i + 1 < malePlayers.length) {
            teams.push({
              id: `${malePlayers[i].id}_${malePlayers[i + 1].id}`,
              players: [malePlayers[i], malePlayers[i + 1]],
              name: `${malePlayers[i].name}/${malePlayers[i + 1].name}`,
              type: 'male' // æ ‡è®°ä¸ºç”·å?            });
          }
        }
        
        // å°½å¯èƒ½ç»„æˆå¥³å?        for (let i = 0; i < femalePlayers.length - 1; i += 2) {
          if (i + 1 < femalePlayers.length) {
            teams.push({
              id: `${femalePlayers[i].id}_${femalePlayers[i + 1].id}`,
              players: [femalePlayers[i], femalePlayers[i + 1]],
              name: `${femalePlayers[i].name}/${femalePlayers[i + 1].name}`,
              type: 'female' // æ ‡è®°ä¸ºå¥³å?            });
          }
        }
        
        // å‰©ä½™çš„ç”·é€‰æ‰‹å’Œå¥³é€‰æ‰‹ç»„æˆæ··åŒ
        const remainingMales = malePlayers.length % 2 === 1 ? [malePlayers[malePlayers.length - 1]] : [];
        const remainingFemales = femalePlayers.length % 2 === 1 ? [femalePlayers[femalePlayers.length - 1]] : [];
        
        const minCount = Math.min(remainingMales.length, remainingFemales.length);
        for (let i = 0; i < minCount; i++) {
        teams.push({
            id: `${remainingMales[i].id}_${remainingFemales[i].id}`,
            players: [remainingMales[i], remainingFemales[i]],
            name: `${remainingMales[i].name}/${remainingFemales[i].name}`,
            type: 'mixed' // æ ‡è®°ä¸ºæ··å?          });
        }
        
        // å¦‚æœè¿˜æœ‰å‰©ä½™é€‰æ‰‹ï¼Œä¸¤ä¸¤ç»„å?        const allRemaining = [...remainingMales.slice(minCount), ...remainingFemales.slice(minCount)];
        for (let i = 0; i < allRemaining.length - 1; i += 2) {
          if (i + 1 < allRemaining.length) {
            const type = allRemaining[i].gender === allRemaining[i + 1].gender ? 
                        (allRemaining[i].gender === 'male' ? 'male' : 'female') : 'mixed';
            teams.push({
              id: `${allRemaining[i].id}_${allRemaining[i + 1].id}`,
              players: [allRemaining[i], allRemaining[i + 1]],
              name: `${allRemaining[i].name}/${allRemaining[i + 1].name}`,
              type: type
            });
          }
        }
      
      for (let i = 0; i < teams.length; i++) {
        const row = {
          team: teams[i],
          matches: []
        };
        
        for (let j = 0; j < teams.length; j++) {
          if (i === j) {
            // è‡ªå·±å¯¹è‡ªå·±ï¼Œæ˜¾ç¤ºæ–œæ 
            row.matches.push({
              opponent: teams[j],
              score: '/',
              isSelfMatch: true
            });
          } else {
            // æŸ¥æ‰¾æ˜¯å¦å·²æœ‰æ¯”èµ›è®°å½•
            const existingTable = this.data.matchTable || [];
            const existingRow = existingTable.find(r => r.team && r.team.id === teams[i].id);
            const existingMatch = existingRow ? existingRow.matches.find(m => m.opponent.id === teams[j].id) : null;
            
            row.matches.push({
              opponent: teams[j],
              score: existingMatch ? existingMatch.score : '',
              id: `match_${teams[i].id}_${teams[j].id}`
            });
          }
        }
        
        matchTable.push(row);
        }
      }
    } else {
      // ç‘å£«è½®æ¯”èµ?      if (mode === 'singles') {
        // å•æ‰“æ¨¡å¼
        if (currentRound === 1) {
          // ç¬¬ä¸€è½®æŒ‰ç…§åˆå§‹æ’åé…å¯¹ï¼š1 vs n/2+1, 2 vs n/2+2, ...
          const n = selectedPlayers.length;
          const halfN = Math.ceil(n / 2);
          
          // ç¡®ä¿æ‰€æœ‰é€‰æ‰‹éƒ½èƒ½å‚ä¸æ¯”èµ›
          for (let i = 0; i < halfN; i++) {
            if (i + halfN < n) {
              // æ­£å¸¸é…å¯¹
              const match = {
                round: 1,
                player1: selectedPlayers[i],
                player2: selectedPlayers[i + halfN],
                score: '',
                winner: null
              };
              
              matchTable.push(match);
            } else if (i < n) {
              // å¦‚æœé€‰æ‰‹æ•°é‡ä¸ºå¥‡æ•°ï¼Œæœ€åä¸€åé€‰æ‰‹è½®ç©ºæˆ–å®‰æ’ç‰¹æ®Šæ¯”èµ?              console.log("é€‰æ‰‹æ•°é‡ä¸ºå¥‡æ•°ï¼Œæœ€åä¸€åé€‰æ‰‹è½®ç©º");
              // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ è½®ç©ºé€»è¾‘
            }
          }
        } else {
          // åç»­è½®æ¬¡æŒ‰ç…§å½“å‰æ’åé…å¯¹
          // è¿™é‡Œç®€å•å®ç°ï¼Œå®é™…ç‘å£«è½®æœ‰æ›´å¤æ‚çš„é…å¯¹è§„åˆ™
          const availablePlayers = [...playerRankings];
          
          while (availablePlayers.length >= 2) {
            const player1 = availablePlayers.shift();
            
            // æ‰¾åˆ°æœªæ›¾å¯¹é˜µè¿‡çš„å¯¹æ‰‹
            let opponentIndex = -1;
            for (let i = 0; i < availablePlayers.length; i++) {
              if (!player1.opponents.includes(availablePlayers[i].id)) {
                opponentIndex = i;
                break;
              }
            }
            
            // å¦‚æœæ‰¾ä¸åˆ°æœªæ›¾å¯¹é˜µè¿‡çš„å¯¹æ‰‹ï¼Œå°±é€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨çš„å¯¹æ‰‹
            if (opponentIndex === -1 && availablePlayers.length > 0) {
              opponentIndex = 0;
            }
            
            if (opponentIndex !== -1) {
              const player2 = availablePlayers.splice(opponentIndex, 1)[0];
              
              const match = {
                round: currentRound,
                player1: player1,
                player2: player2,
                score: '',
                winner: null
              };
              
              matchTable.push(match);
            }
          }
        }
      } else {
        // åŒæ‰“æ¨¡å¼
        if (currentRound === 1) {
          // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„åŒæ‰“ç»„åˆ
          const teams = [];
          for (let i = 0; i < selectedPlayers.length; i += 2) {
            if (i + 1 < selectedPlayers.length) {
              teams.push({
                id: `${selectedPlayers[i].id}_${selectedPlayers[i + 1].id}`,
                players: [selectedPlayers[i], selectedPlayers[i + 1]],
                name: `${selectedPlayers[i].name}/${selectedPlayers[i + 1].name}`,
                wins: 0,
                losses: 0,
                points: 0,
                opponents: []
              });
            }
          }

          // ä¿å­˜é˜Ÿä¼ä¿¡æ¯åˆ°playerRankings
          this.setData({
            playerRankings: teams
          });
          
          // ç¬¬ä¸€è½®æŒ‰ç…§é˜Ÿä¼æ•°é‡é…å¯?          const n = teams.length;
          const halfN = Math.ceil(n / 2);
          
          // ç¡®ä¿æ‰€æœ‰é˜Ÿä¼éƒ½èƒ½å‚ä¸æ¯”èµ?          for (let i = 0; i < halfN; i++) {
            if (i + halfN < n) {
              // æ­£å¸¸é…å¯¹
              const match = {
                round: 1,
                team1: teams[i],
                team2: teams[i + halfN],
                score: '',
                winner: null
              };
              
              matchTable.push(match);
            } else if (i < n) {
              // å¦‚æœé˜Ÿä¼æ•°é‡ä¸ºå¥‡æ•°ï¼Œæœ€åä¸€æ”¯é˜Ÿä¼è½®ç©ºæˆ–å®‰æ’ç‰¹æ®Šæ¯”èµ›
              console.log("é˜Ÿä¼æ•°é‡ä¸ºå¥‡æ•°ï¼Œæœ€åä¸€æ”¯é˜Ÿä¼è½®ç©?);
              // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ è½®ç©ºé€»è¾‘
            }
          }
        } else {
          // åç»­è½®æ¬¡æŒ‰ç…§å½“å‰æ’åé…å¯¹
          // è¿™é‡Œç®€å•å®ç°ï¼Œå®é™…ç‘å£«è½®æœ‰æ›´å¤æ‚çš„é…å¯¹è§„åˆ™
          const availableTeams = [...this.data.playerRankings];
          
          while (availableTeams.length >= 2) {
            const team1 = availableTeams.shift();
            
            // æ‰¾åˆ°æœªæ›¾å¯¹é˜µè¿‡çš„å¯¹æ‰‹
            let opponentIndex = -1;
            for (let i = 0; i < availableTeams.length; i++) {
              if (!team1.opponents.includes(availableTeams[i].id)) {
                opponentIndex = i;
                break;
              }
            }
            
            // å¦‚æœæ‰¾ä¸åˆ°æœªæ›¾å¯¹é˜µè¿‡çš„å¯¹æ‰‹ï¼Œå°±é€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨çš„å¯¹æ‰‹
            if (opponentIndex === -1 && availableTeams.length > 0) {
              opponentIndex = 0;
            }
            
            if (opponentIndex !== -1) {
              const team2 = availableTeams.splice(opponentIndex, 1)[0];
              
              const match = {
                round: currentRound,
                team1: team1,
                team2: team2,
                score: '',
                winner: null
              };
              
              matchTable.push(match);
            }
          }
        }
      }
    }
    
    this.setData({
      matchTable: matchTable
    });
  },
  
  /**
   * ä¿å­˜è¿›è¡Œä¸­çš„æ¯”èµ›
   */
  saveOngoingMatch: function() {
    const { selectedPlayers, matchTable, mode, tournamentType, currentRound, totalRounds, playerRankings } = this.data;
    
    const storageKey = tournamentType === 'swiss' ? 'ongoingSwissMatch' : 'ongoingRoundRobinMatch';
    
    // å¦‚æœæ˜¯ç‘å£«è½®ï¼Œä¿ç•™ä¹‹å‰çš„æ‰€æœ‰æ¯”èµ›è®°å½?    if (tournamentType === 'swiss') {
      const ongoingMatch = wx.getStorageSync(storageKey) || {};
      const allMatches = ongoingMatch.allMatches || [];
      
      wx.setStorageSync(storageKey, {
        mode: mode,
        tournamentType: tournamentType,
        players: selectedPlayers,
        matchTable: matchTable,
        currentRound: currentRound,
        totalRounds: totalRounds,
        playerRankings: playerRankings,
        allMatches: allMatches, // ä¿å­˜æ‰€æœ‰è½®æ¬¡çš„æ¯”èµ›
        updateTime: new Date().toISOString()
      });
    } else {
      wx.setStorageSync(storageKey, {
        mode: mode,
        tournamentType: tournamentType,
        players: selectedPlayers,
        matchTable: matchTable,
        currentRound: currentRound,
        totalRounds: totalRounds,
        playerRankings: playerRankings,
        updateTime: new Date().toISOString()
      });
    }
  },
  
  /**
   * è¾“å…¥æ¯”åˆ†
   */
  inputScore: function(e) {
    const { row, col } = e.currentTarget.dataset;
    // è·å–åˆ†æ•°ï¼Œä¼˜å…ˆä»dataset.scoreè·å–ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä»detail.valueè·å–
    const score = e.currentTarget.dataset.score || e.detail.value;
    
    // æ›´æ–°æ¯”åˆ†
    const matchTable = [...this.data.matchTable];
    matchTable[row].matches[col].score = score;
    
    // åŒæ—¶æ›´æ–°å¯¹åº”çš„åå‘æ¯”åˆ?    const player1 = matchTable[row].player || matchTable[row].team;
    const player2 = matchTable[row].matches[col].opponent;
    
    const reverseRow = matchTable.findIndex(r => 
      (r.player && r.player.id === player2.id) || 
      (r.team && r.team.id === player2.id)
    );
    
    const reverseCol = matchTable[reverseRow].matches.findIndex(m => 
      (m.opponent.id === player1.id)
    );
    
    matchTable[reverseRow].matches[reverseCol].score = score;
    
    this.setData({
      matchTable: matchTable
    });
    
    // ä¿å­˜è¿›è¡Œä¸­çš„æ¯”èµ›
    this.saveOngoingMatch();
  },
  
  /**
   * è¾“å…¥ç‘å£«è½®æ¯”èµ›æ¯”åˆ?   */
  inputSwissScore: function(e) {
    const matchIndex = e.currentTarget.dataset.matchIndex;
    const score = e.detail.value;
    
    // æ›´æ–°æ¯”åˆ†
    const matchTable = [...this.data.matchTable];
    matchTable[matchIndex].score = score;
    
    // è§£ææ¯”åˆ†
    const scores = score.split(':');
    if (scores.length === 2) {
      const leftScore = parseInt(scores[0]);
      const rightScore = parseInt(scores[1]);
      
      if (!isNaN(leftScore) && !isNaN(rightScore)) {
        if (leftScore > rightScore) {
          matchTable[matchIndex].winner = 'player1';
        } else if (rightScore > leftScore) {
          matchTable[matchIndex].winner = 'player2';
        } else {
          matchTable[matchIndex].winner = 'tie';
        }
      }
    }
    
    this.setData({
      matchTable: matchTable
    });
    
    // ä¿å­˜è¿›è¡Œä¸­çš„æ¯”èµ›
    this.saveOngoingMatch();
  },
  
  /**
   * è¿›å…¥ä¸‹ä¸€è½?   */
  nextRound: function() {
    const { matchTable, currentRound, totalRounds, mode } = this.data;
    
    // æ£€æŸ¥å½“å‰è½®æ¬¡æ˜¯å¦æ‰€æœ‰æ¯”èµ›éƒ½å·²å®Œæˆ?    const allMatchesCompleted = matchTable.every(match => match.winner);
    
    if (!allMatchesCompleted) {
      wx.showModal({
        title: 'æœªå®Œæˆæ¯”èµ?,
        content: 'å½“å‰è½®æ¬¡è¿˜æœ‰æœªå®Œæˆçš„æ¯”èµ›ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ',
        success: (res) => {
          if (res.confirm) {
            this.processCurrentRound();
          }
        }
      });
    } else {
      this.processCurrentRound();
    }
  },
  
  /**
   * å¤„ç†å½“å‰è½®æ¬¡ç»“æœå¹¶è¿›å…¥ä¸‹ä¸€è½?   */
  processCurrentRound: function() {
    const { matchTable, currentRound, mode, playerRankings } = this.data;
    
    // æ›´æ–°é€‰æ‰‹æ’å
    const updatedRankings = [...playerRankings];
    
    // å¤„ç†æœ¬è½®æ¯”èµ›ç»“æœ
    for (const match of matchTable) {
      // è·³è¿‡æ²¡æœ‰ç»“æœçš„æ¯”èµ?      if (!match.winner) continue;
      
      if (mode === 'singles') {
        // å•æ‰“æ¨¡å¼
        const player1Index = updatedRankings.findIndex(p => p.id === match.player1.id);
        const player2Index = updatedRankings.findIndex(p => p.id === match.player2.id);
        
        if (player1Index !== -1 && player2Index !== -1) {
          // è®°å½•å¯¹æ‰‹
          updatedRankings[player1Index].opponents.push(match.player2.id);
          updatedRankings[player2Index].opponents.push(match.player1.id);
          
          // æ›´æ–°èƒœè´Ÿåœºæ¬¡å’Œç§¯åˆ?          if (match.winner === 'player1') {
            updatedRankings[player1Index].wins++;
            updatedRankings[player1Index].points += 2;
            updatedRankings[player2Index].losses++;
          } else if (match.winner === 'player2') {
            updatedRankings[player2Index].wins++;
            updatedRankings[player2Index].points += 2;
            updatedRankings[player1Index].losses++;
          } else if (match.winner === 'tie') {
            updatedRankings[player1Index].points += 1;
            updatedRankings[player2Index].points += 1;
          }
        }
      } else {
        // åŒæ‰“æ¨¡å¼
        const team1Index = updatedRankings.findIndex(t => t.id === match.team1.id);
        const team2Index = updatedRankings.findIndex(t => t.id === match.team2.id);
        
        if (team1Index !== -1 && team2Index !== -1) {
          // è®°å½•å¯¹æ‰‹
          updatedRankings[team1Index].opponents.push(match.team2.id);
          updatedRankings[team2Index].opponents.push(match.team1.id);
          
          // æ›´æ–°èƒœè´Ÿåœºæ¬¡å’Œç§¯åˆ?          if (match.winner === 'player1') {
            updatedRankings[team1Index].wins++;
            updatedRankings[team1Index].points += 2;
            updatedRankings[team2Index].losses++;
          } else if (match.winner === 'player2') {
            updatedRankings[team2Index].wins++;
            updatedRankings[team2Index].points += 2;
            updatedRankings[team1Index].losses++;
          } else if (match.winner === 'tie') {
            updatedRankings[team1Index].points += 1;
            updatedRankings[team2Index].points += 1;
          }
        }
      }
    }
    
    // æŒ‰ç§¯åˆ†æ’åº?    updatedRankings.sort((a, b) => {
      if (a.points !== b.points) return b.points - a.points;
      if (a.wins !== b.wins) return b.wins - a.wins;
      return 0;
    });
    
    // ä¿å­˜å½“å‰è½®æ¬¡çš„æ¯”èµ›è®°å½•åˆ°æœ¬åœ°å­˜å‚¨
    const ongoingMatch = wx.getStorageSync('ongoingSwissMatch') || {};
    const allMatches = ongoingMatch.allMatches || [];
    
    // å°†å½“å‰è½®æ¬¡çš„æ¯”èµ›æ·»åŠ åˆ°å†å²è®°å½?    const currentRoundMatches = matchTable.filter(match => match.winner);
    allMatches.push(...currentRoundMatches);
    
    // æ›´æ–°æœ¬åœ°å­˜å‚¨
    ongoingMatch.allMatches = allMatches;
    wx.setStorageSync('ongoingSwissMatch', ongoingMatch);
    
    // è¿›å…¥ä¸‹ä¸€è½?    this.setData({
      currentRound: currentRound + 1,
      playerRankings: updatedRankings
    });
    
    // ç”Ÿæˆä¸‹ä¸€è½®æ¯”èµ?    this.generateMatchTable();
    
    // ä¿å­˜è¿›è¡Œä¸­çš„æ¯”èµ›
    this.saveOngoingMatch();
  },
  
  /**
   * ç»“æŸæ¯”èµ›
   */
  endMatch: function() {
    const that = this;
    wx.showModal({
      title: 'ç¡®è®¤ç»“æŸæ¯”èµ›',
      content: 'ç»“æŸæ¯”èµ›åå°†æ— æ³•ç»§ç»­è®°åˆ†ï¼Œç¡®å®šè¦ç»“æŸå—ï¼Ÿ',
      success: function(res) {
        if (res.confirm) {
          // å¤„ç†æ¯”èµ›ç»“æœ
          that.processMatchResults();
          
          // æ¸…é™¤è¿›è¡Œä¸­çš„æ¯”èµ›
          const storageKey = that.data.tournamentType === 'swiss' ? 'ongoingSwissMatch' : 'ongoingRoundRobinMatch';
          wx.removeStorageSync(storageKey);
          
          // å¦‚æœæ˜¯ç‘å£«è½®æ¯”èµ›ï¼Œæ˜¾ç¤ºæ’åç»“æ?          if (that.data.tournamentType === 'swiss') {
            that.showRankingModal();
          } else {
            // ç›´æ¥è¿”å›ä¸»é¡µ
            wx.reLaunch({
              url: '/pages/index/index'
            });
          }
        }
      }
    });
  },
  
  /**
   * æ˜¾ç¤ºæ’åç»“æœå¼¹çª—
   */
  showRankingModal: function() {
    // ç¡®ä¿æ’åæ˜¯æŒ‰ç…§ç§¯åˆ†å’Œèƒœåœºæ’åºçš?    const playerRankings = [...this.data.playerRankings];
    playerRankings.sort((a, b) => {
      if (a.points !== b.points) return b.points - a.points;
      if (a.wins !== b.wins) return b.wins - a.wins;
      return 0;
    });
    
    this.setData({
      showRankingModal: true,
      playerRankings: playerRankings
    });
  },
  
  /**
   * éšè—æ’åç»“æœå¼¹çª—
   */
  hideRankingModal: function() {
    this.setData({
      showRankingModal: false
    });
  },
  
  /**
   * ç¡®è®¤æ’åç»“æœ
   */
  confirmRanking: function() {
    this.hideRankingModal();
    
    // è¿”å›ä¸»é¡µ
    wx.reLaunch({
      url: '/pages/index/index'
    });
  },
  
  /**
   * å¤„ç†æ¯”èµ›ç»“æœ
   */
  processMatchResults: function() {
    const { matchTable, mode, tournamentType, currentRound, playerRankings } = this.data;
    const matchHistory = [];
    
    // æ·»åŠ æ£€æŸ¥ä¸´æ—¶é€‰æ‰‹çš„è¾…åŠ©å‡½æ•?    const hasTemporaryPlayer = (players) => {
      return players.some(player => player.isTemporary === true);
    };
    
    if (tournamentType === 'round_robin') {
      // å®Œå…¨å¾ªç¯èµ?    // éå†æ¯”èµ›è¡¨æ ¼ï¼Œæå–æœ‰æ•ˆæ¯”èµ›ç»“æ?    for (let i = 0; i < matchTable.length; i++) {
      for (let j = 0; j < matchTable[i].matches.length; j++) {
        const match = matchTable[i].matches[j];
        
        // è·³è¿‡è‡ªå·±å¯¹è‡ªå·±çš„æ¯”èµ›å’Œæ²¡æœ‰æ¯”åˆ†çš„æ¯”èµ›
        if (match.score === '-' || match.score === '') continue;
        
        // è·³è¿‡å·²å¤„ç†è¿‡çš„æ¯”èµ›ï¼ˆé¿å…é‡å¤ï¼?        if (i > j) continue;
        
        // è§£ææ¯”åˆ†
        const scores = match.score.split(':');
        if (scores.length !== 2) continue;
        
        const leftScore = parseInt(scores[0]);
        const rightScore = parseInt(scores[1]);
        
        if (isNaN(leftScore) || isNaN(rightScore)) continue;
        
        // åˆ›å»ºæ¯”èµ›è®°å½•
        let matchRecord;
        let leftTeamPlayers, rightTeamPlayers;
        
        if (mode === 'singles') {
          leftTeamPlayers = [matchTable[i].player];
          rightTeamPlayers = [match.opponent];
          
          matchRecord = {
            id: Date.now().toString() + '_' + i + '_' + j,
            date: new Date().toISOString(),
            leftTeam: leftTeamPlayers,
            rightTeam: rightTeamPlayers,
            leftScore: leftScore,
            rightScore: rightScore,
            winner: leftScore > rightScore ? 'left' : 'right'
          };
        } else {
          leftTeamPlayers = matchTable[i].team.players;
          rightTeamPlayers = match.opponent.players;
          
          matchRecord = {
            id: Date.now().toString() + '_' + i + '_' + j,
            date: new Date().toISOString(),
            leftTeam: leftTeamPlayers,
            rightTeam: rightTeamPlayers,
            leftScore: leftScore,
            rightScore: rightScore,
            winner: leftScore > rightScore ? 'left' : 'right'
            };
          }
          
          // æ£€æŸ¥æ˜¯å¦åŒ…å«ä¸´æ—¶é€‰æ‰‹ï¼Œå¦‚æœåŒ…å«åˆ™ä¸è®°å½?          if (hasTemporaryPlayer(leftTeamPlayers) || hasTemporaryPlayer(rightTeamPlayers)) {
            continue;
          }
          
          // ä½¿ç”¨ELOç³»ç»Ÿæ›´æ–°ç§¯åˆ†
          const scoreChanges = app.submitMatch(matchRecord);
          
          // å°†ç§¯åˆ†å˜åŒ–å€¼æ·»åŠ åˆ°æ¯”èµ›è®°å½•ä¸?          matchRecord.winnerChange = scoreChanges.winnerChange;
          matchRecord.loserChange = scoreChanges.loserChange;
          
          // æ·»åŠ åˆ°å†å²è®°å½?          matchHistory.push(matchRecord);
        }
      }
    } else {
      // ç‘å£«è½®æ¯”èµ?      // è·å–è¿›è¡Œä¸­çš„ç‘å£«è½®æ¯”èµ›æ•°æ®ï¼ŒåŒ…æ‹¬æ‰€æœ‰è½®æ¬¡çš„æ¯”èµ›
      const ongoingMatch = wx.getStorageSync('ongoingSwissMatch');
      // ä½¿ç”¨allMatchesè€Œä¸æ˜¯matchTableï¼Œç¡®ä¿åŒ…å«æ‰€æœ‰è½®æ¬¡çš„æ¯”èµ›
      const allRoundMatches = ongoingMatch ? (ongoingMatch.allMatches || []) : [];
      
      // å¤„ç†æ‰€æœ‰è½®æ¬¡çš„æ¯”èµ›
      for (const match of allRoundMatches) {
        // è·³è¿‡æ²¡æœ‰æ¯”åˆ†çš„æ¯”èµ?        if (!match.score || !match.winner) continue;
        
        // è§£ææ¯”åˆ†
        const scores = match.score.split(':');
        if (scores.length !== 2) continue;
        
        const leftScore = parseInt(scores[0]);
        const rightScore = parseInt(scores[1]);
        
        if (isNaN(leftScore) || isNaN(rightScore)) continue;
        
        // åˆ›å»ºæ¯”èµ›è®°å½•
        let matchRecord;
        let leftTeamPlayers, rightTeamPlayers;
        const matchRound = match.round || 1; // ç¡®ä¿æœ‰è½®æ¬¡ä¿¡æ?        
        if (mode === 'singles') {
          leftTeamPlayers = [match.player1];
          rightTeamPlayers = [match.player2];
          
          matchRecord = {
            id: Date.now().toString() + '_' + match.player1.id + '_' + match.player2.id + '_round' + matchRound,
            date: new Date().toISOString(),
            leftTeam: leftTeamPlayers,
            rightTeam: rightTeamPlayers,
            leftScore: leftScore,
            rightScore: rightScore,
            winner: match.winner === 'player1' ? 'left' : 'right',
            round: matchRound // æ·»åŠ è½®æ¬¡ä¿¡æ¯
          };
        } else {
          leftTeamPlayers = match.team1.players;
          rightTeamPlayers = match.team2.players;
          
          matchRecord = {
            id: Date.now().toString() + '_' + match.team1.id + '_' + match.team2.id + '_round' + matchRound,
            date: new Date().toISOString(),
            leftTeam: leftTeamPlayers,
            rightTeam: rightTeamPlayers,
            leftScore: leftScore,
            rightScore: rightScore,
            winner: match.winner === 'player1' ? 'left' : 'right',
            round: matchRound // æ·»åŠ è½®æ¬¡ä¿¡æ¯
          };
        }
        
        // æ£€æŸ¥æ˜¯å¦åŒ…å«ä¸´æ—¶é€‰æ‰‹ï¼Œå¦‚æœåŒ…å«åˆ™ä¸è®°å½?        if (hasTemporaryPlayer(leftTeamPlayers) || hasTemporaryPlayer(rightTeamPlayers)) {
          continue;
        }
        
        // ä½¿ç”¨ELOç³»ç»Ÿæ›´æ–°ç§¯åˆ†
        const scoreChanges = app.submitMatch(matchRecord);
        
        // å°†ç§¯åˆ†å˜åŒ–å€¼æ·»åŠ åˆ°æ¯”èµ›è®°å½•ä¸?        matchRecord.winnerChange = scoreChanges.winnerChange;
        matchRecord.loserChange = scoreChanges.loserChange;
        
        // æ·»åŠ åˆ°å†å²è®°å½?        matchHistory.push(matchRecord);
      }
    }
    
    // æ›´æ–°å…¨å±€æ¯”èµ›è®°å½•
    const allMatchHistory = [...app.globalData.matchHistory, ...matchHistory];
    app.globalData.matchHistory = allMatchHistory;
    
    // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚?    wx.setStorageSync('matchHistory', allMatchHistory);
  },

  /**
   * æ˜¾ç¤ºæ·»åŠ ä¸´æ—¶é€‰æ‰‹å¼¹çª—
   */
  showAddTempPlayerModal: function() {
    this.setData({
      showAddTempPlayerModal: true,
      tempPlayerName: '',
      tempPlayerGender: 'male'
    });
  },

  /**
   * éšè—æ·»åŠ ä¸´æ—¶é€‰æ‰‹å¼¹çª—
   */
  hideAddTempPlayerModal: function() {
    this.setData({
      showAddTempPlayerModal: false
    });
  },

  /**
   * ç›‘å¬ä¸´æ—¶é€‰æ‰‹å§“åè¾“å…¥
   */
  onTempPlayerNameInput: function(e) {
    this.setData({
      tempPlayerName: e.detail.value
    });
  },

  /**
   * é€‰æ‹©ä¸´æ—¶é€‰æ‰‹æ€§åˆ«
   */
  selectTempPlayerGender: function(e) {
    const gender = e.currentTarget.dataset.gender;
    this.setData({
      tempPlayerGender: gender
    });
  },

  /**
   * æ·»åŠ ä¸´æ—¶é€‰æ‰‹
   */
  addTempPlayer: function() {
    const { tempPlayerName, tempPlayerGender, players } = this.data;
    
    // éªŒè¯å§“å
    if (!tempPlayerName.trim()) {
      wx.showToast({
        title: 'è¯·è¾“å…¥é€‰æ‰‹å§“å',
        icon: 'none'
      });
      return;
    }
    
    // æ£€æŸ¥åç§°æ˜¯å¦é‡å¤?    const nameExists = players.some(player => player.name === tempPlayerName);
    
    // åˆ›å»ºä¸´æ—¶é€‰æ‰‹å¯¹è±¡ï¼Œæ·»åŠ?ä¸?æ ‡è¯†
    const displayName = nameExists ? `${tempPlayerName}(ä¸?` : `${tempPlayerName}(ä¸?`;
    
    const tempPlayer = {
      id: 'temp_' + Date.now(),
      name: displayName,
      gender: tempPlayerGender,
      score: 1000, // é»˜è®¤åˆ†æ•°
      avatarUrl: tempPlayerGender === 'female' ? '/images/default-avatar-female.png' : '/images/default-avatar.png',
      isTemporary: true
    };
    
    // æ·»åŠ åˆ°é€‰æ‰‹åˆ—è¡¨å’Œå·²é€‰æ‹©åˆ—è¡¨
    const updatedPlayers = [...this.data.players, tempPlayer];
    const updatedSelectedPlayers = [...this.data.selectedPlayers, tempPlayer];
    
    this.setData({
      players: updatedPlayers,
      selectedPlayers: updatedSelectedPlayers,
      showAddTempPlayerModal: false
    });
    
    wx.showToast({
      title: 'ä¸´æ—¶é€‰æ‰‹å·²æ·»åŠ?,
      icon: 'success'
    });
  },

  /**
   * æ˜¾ç¤ºæ¯”åˆ†è¾“å…¥å¼¹çª—
   */
  showScoreInputModal: function(e) {
    const row = e.currentTarget.dataset.row;
    const col = e.currentTarget.dataset.col;
    const matchIndex = e.currentTarget.dataset.matchIndex;
    
    // åˆ¤æ–­æ˜¯å¦ä¸ºç‘å£«è½®æ¯”èµ›
    if (this.data.tournamentType === 'swiss') {
      // è·å–ç‘å£«è½®æ¯”èµ›æ•°æ?      const match = this.data.matchTable[matchIndex];
      const team = this.data.mode === 'singles' ? match.player1 : match.team1;
      const opponent = this.data.mode === 'singles' ? match.player2 : match.team2;
      
      // è§£æå·²æœ‰çš„æ¯”åˆ?      let teamScore = '';
      let opponentScore = '';
      if (match.score && match.score.includes(':')) {
        const scores = match.score.split(':');
        teamScore = scores[0];
        opponentScore = scores[1];
      }
      
      this.setData({
        showScoreInputModal: true,
        currentMatch: {
          matchIndex: matchIndex,
          team: team,
          opponent: opponent,
          isSwiss: true
        },
        teamScore: teamScore,
        opponentScore: opponentScore,
        activeScoreInput: 'team' // é»˜è®¤æ¿€æ´»é˜Ÿä¼åˆ†æ•°è¾“å…¥æ¡†
      });
    } else {
      // è·å–å¯¹åº”çš„æ¯”èµ›æ•°æ?      const match = this.data.matchTable[row].matches[col];
      const team = this.data.matchTable[row].player || this.data.matchTable[row].team;
      const opponent = match.opponent;
      
      // è§£æå·²æœ‰çš„æ¯”åˆ?      let teamScore = '';
      let opponentScore = '';
      if (match.score && match.score.includes(':')) {
        const scores = match.score.split(':');
        teamScore = scores[0];
        opponentScore = scores[1];
      }
      
      this.setData({
        showScoreInputModal: true,
        currentMatch: {
          row: row,
          col: col,
          team: team,
          opponent: opponent,
          isSwiss: false
        },
        teamScore: teamScore,
        opponentScore: opponentScore,
        activeScoreInput: 'team' // é»˜è®¤æ¿€æ´»é˜Ÿä¼åˆ†æ•°è¾“å…¥æ¡†
      });
    }
  },
  
  /**
   * éšè—æ¯”åˆ†è¾“å…¥å¼¹çª—
   */
  hideScoreInputModal: function() {
    this.setData({
      showScoreInputModal: false,
      currentMatch: null,
      teamScore: '',
      opponentScore: ''
    });
  },
  
  /**
   * å¤„ç†é˜Ÿä¼åˆ†æ•°è¾“å…¥
   */
  onTeamScoreInput: function(e) {
    this.setData({
      teamScore: e.detail.value
    });
  },
  
  /**
   * å¤„ç†å¯¹æ‰‹åˆ†æ•°è¾“å…¥
   */
  onOpponentScoreInput: function(e) {
    this.setData({
      opponentScore: e.detail.value
    });
  },
  
  /**
   * è®¾ç½®å¿«æ·åˆ†æ•°
   */
  setQuickScore: function(e) {
    const { team, opponent } = e.currentTarget.dataset;
    
    this.setData({
      teamScore: team,
      opponentScore: opponent
    });
  },
  
  /**
   * ç¡®è®¤æ¯”åˆ†
   */
  confirmScore: function() {
    const { currentMatch, teamScore, opponentScore } = this.data;
    
    if (!teamScore && !opponentScore) {
      wx.showToast({
        title: 'è¯·è¾“å…¥æ¯”åˆ?,
        icon: 'none'
      });
      return;
    }
    
    if (currentMatch.isSwiss) {
      // å¤„ç†ç‘å£«è½®æ¯”èµ›çš„æ¯”åˆ†
      const score = teamScore + ':' + opponentScore;
      
      // æ›´æ–°æ¯”åˆ†
      const matchTable = [...this.data.matchTable];
      matchTable[currentMatch.matchIndex].score = score;
      
      // è§£ææ¯”åˆ†
      const leftScore = parseInt(teamScore);
      const rightScore = parseInt(opponentScore);
      
      if (!isNaN(leftScore) && !isNaN(rightScore)) {
        if (leftScore > rightScore) {
          matchTable[currentMatch.matchIndex].winner = 'player1';
        } else if (rightScore > leftScore) {
          matchTable[currentMatch.matchIndex].winner = 'player2';
        } else {
          matchTable[currentMatch.matchIndex].winner = 'tie';
        }
      }
      
      this.setData({
        matchTable: matchTable
      });
    } else {
      // è°ƒç”¨åŸæœ‰çš„inputScoreæ–¹æ³•å¤„ç†åˆ†æ•°
      this.inputScore({
        currentTarget: {
          dataset: {
            row: currentMatch.row,
            col: currentMatch.col,
            score: teamScore + ':' + opponentScore
          }
        }
      });
    }
    
    // ä¿å­˜è¿›è¡Œä¸­çš„æ¯”èµ›
    this.saveOngoingMatch();
    
    // éšè—å¼¹çª—
    this.hideScoreInputModal();
  },

  /**
   * æ¸…é™¤åŒæ‰“ç»„åˆ
   */
  clearTeam: function(e) {
    const index = e.currentTarget.dataset.index;
    const { selectedPlayers } = this.data;
    let newSelectedPlayers = [...selectedPlayers];
    
    if (index === 0) {
      // æ¸…é™¤ç¬¬ä¸€ç»?      newSelectedPlayers.splice(0, 2);
      // å¦‚æœè¿˜æœ‰ç¬¬äºŒç»„ï¼Œå°†å…¶ç§»åˆ°ç¬¬ä¸€ç»„ä½ç½?      if (newSelectedPlayers.length >= 2) {
        const team2 = newSelectedPlayers.splice(0, 2);
        newSelectedPlayers = team2.concat(newSelectedPlayers);
      }
    } else if (index === 1) {
      // æ¸…é™¤ç¬¬äºŒç»?      newSelectedPlayers.splice(2, 2);
    }
    
    this.setData({
      selectedPlayers: newSelectedPlayers
    });
  },

  /**
   * ç§»é™¤åŒæ‰“ç»„åˆ
   */
  removeDoublesTeam: function(e) {
    const index = e.currentTarget.dataset.index;
    const { selectedPlayers } = this.data;
    let newSelectedPlayers = [...selectedPlayers];
    
    // ç§»é™¤æŒ‡å®šç´¢å¼•å¤„çš„ä¸¤åé€‰æ‰‹
    newSelectedPlayers.splice(index, 2);
    
    this.setData({
      selectedPlayers: newSelectedPlayers
    });
  },

  /**
   * ä»å·²é€‰æ‹©åˆ—è¡¨ä¸­ç§»é™¤é€‰æ‰‹
   */
  removeSelectedPlayer: function(e) {
    const playerId = e.currentTarget.dataset.playerId;
    const selectedPlayers = this.data.selectedPlayers.filter(p => p.id !== playerId);
    
    this.setData({
      selectedPlayers: selectedPlayers
    });
  },

  /**
   * è®¾ç½®å½“å‰æ¿€æ´»çš„åˆ†æ•°è¾“å…¥æ¡?   */
  setActiveScoreInput: function(e) {
    const input = e.currentTarget.dataset.input;
    this.setData({
// è·å–åº”ç”¨å®ä¾‹
const app = getApp();

Page({
  /**
   * é¡µé¢çš„åˆå§‹æ•°æ?   */
  data: {
    mode: 'singles', // é»˜è®¤ä¸ºå•æ‰“æ¨¡å¼?    tournamentType: 'round_robin', // æ¯”èµ›ç±»å‹ï¼šround_robin(å®Œå…¨å¾ªç¯)æˆ–swiss(ç‘å£«è½?
    players: [], // æ‰€æœ‰å¯é€‰æ‹©çš„é€‰æ‰‹
    selectedPlayers: [], // å·²é€‰æ‹©çš„é€‰æ‰‹
    matchTable: [], // æ¯”èµ›è¡¨æ ¼æ•°æ®
    showPlayerSelectModal: false, // æ˜¯å¦æ˜¾ç¤ºé€‰æ‰‹é€‰æ‹©å¼¹çª—
    isMatchStarted: false, // æ¯”èµ›æ˜¯å¦å·²å¼€å§?    isMatchEnded: false, // æ¯”èµ›æ˜¯å¦å·²ç»“æ?    currentRound: 1, // å½“å‰è½®æ¬¡ï¼ˆç‘å£«è½®ä½¿ç”¨ï¼?    totalRounds: 0, // æ€»è½®æ¬¡ï¼ˆç‘å£«è½®ä½¿ç”¨ï¼‰
    playerRankings: [], // é€‰æ‰‹æ’åï¼ˆç‘å£«è½®ä½¿ç”¨ï¼?    showAddTempPlayerModal: false, // æ˜¯å¦æ˜¾ç¤ºæ·»åŠ ä¸´æ—¶é€‰æ‰‹å¼¹çª—
    tempPlayerName: '', // ä¸´æ—¶é€‰æ‰‹å§“å
    tempPlayerGender: 'male', // ä¸´æ—¶é€‰æ‰‹æ€§åˆ«ï¼Œé»˜è®¤ä¸ºç”?    isDoubles: false, // æ˜¯å¦ä¸ºåŒæ‰“æ¨¡å¼?    showScoreInputModal: false,
    currentMatch: null,
    teamScore: '',
    opponentScore: '',
    activeScoreInput: 'team', // å½“å‰æ¿€æ´»çš„åˆ†æ•°è¾“å…¥æ¡†ï¼Œå¯é€‰å€¼ï¼š'team'æˆ?opponent'
    showRankingModal: false, // æ˜¯å¦æ˜¾ç¤ºæ’åç»“æœå¼¹çª—
  },

  /**
   * ç”Ÿå‘½å‘¨æœŸå‡½æ•°--ç›‘å¬é¡µé¢åŠ è½½
   */
  onLoad: function (options) {
    const mode = options.mode || 'singles';
    const tournamentType = options.tournament_type || 'round_robin';
    
    this.setData({
      mode: mode,
      tournamentType: tournamentType,
      isDoubles: mode === 'doubles'
    });
    
    // åŠ è½½é€‰æ‰‹æ•°æ®
    this.loadPlayers();
    
    // æ£€æŸ¥æ˜¯å¦æœ‰è¿›è¡Œä¸­çš„æ¯”èµ›
    this.checkOngoingMatch();
  },
  
  /**
   * åŠ è½½é€‰æ‰‹æ•°æ®
   */
  loadPlayers: function() {
    const allPlayers = app.globalData.players || [];
    
    this.setData({
      players: allPlayers
    });
  },
  
  /**
   * æ£€æŸ¥æ˜¯å¦æœ‰è¿›è¡Œä¸­çš„æ¯”èµ›
   */
  checkOngoingMatch: function() {
    const storageKey = this.data.tournamentType === 'swiss' ? 'ongoingSwissMatch' : 'ongoingRoundRobinMatch';
    const ongoingMatch = wx.getStorageSync(storageKey);
    
    if (ongoingMatch && ongoingMatch.mode === this.data.mode) {
      this.setData({
        selectedPlayers: ongoingMatch.players,
        matchTable: ongoingMatch.matchTable,
        isMatchStarted: true,
        currentRound: ongoingMatch.currentRound || 1,
        totalRounds: ongoingMatch.totalRounds || 0,
        playerRankings: ongoingMatch.playerRankings || []
      });
    }
  },
  
  /**
   * æ˜¾ç¤ºé€‰æ‰‹é€‰æ‹©å¼¹çª—
   */
  showPlayerSelect: function() {
    this.setData({
      showPlayerSelectModal: true
    });
  },
  
  /**
   * éšè—é€‰æ‰‹é€‰æ‹©å¼¹çª—
   */
  hidePlayerSelect: function() {
    this.setData({
      showPlayerSelectModal: false
    });
  },
  
  /**
   * åˆ‡æ¢é€‰æ‰‹é€‰æ‹©çŠ¶æ€?   */
  togglePlayerSelection: function(e) {
    const playerId = e.currentTarget.dataset.id;
    const { selectedPlayers, isDoubles, players } = this.data;
    
    // æŸ¥æ‰¾é€‰æ‰‹å¯¹è±¡
    const player = players.find(p => p.id === playerId);
    if (!player) return;
    
    // æŸ¥æ‰¾é€‰æ‰‹æ˜¯å¦å·²è¢«é€‰ä¸­
    const index = selectedPlayers.findIndex(p => p.id === playerId);
    
    // å¦‚æœæ˜¯åŒæ‰“æ¨¡å¼?    if (isDoubles) {
      // å¦‚æœå·²ç»é€‰æ‹©äº?åé€‰æ‰‹ï¼Œä¸”å½“å‰é€‰æ‰‹æœªè¢«é€‰ä¸­ï¼Œåˆ™ä¸å…è®¸å†é€?      if (selectedPlayers.length >= 4 && index === -1) {
        wx.showToast({
          title: 'åŒæ‰“æ¨¡å¼æœ€å¤šé€‰æ‹©4åé€‰æ‰‹',
          icon: 'none'
        });
        return;
      }
      
      // åˆ‡æ¢é€‰æ‹©çŠ¶æ€?      let newSelectedPlayers = [...selectedPlayers];
      if (index !== -1) {
        // å–æ¶ˆé€‰æ‹©
        newSelectedPlayers.splice(index, 1);
      } else {
        // æ·»åŠ é€‰æ‹©
        newSelectedPlayers.push(player);
      }
      
      this.setData({
        selectedPlayers: newSelectedPlayers
      });
    } else {
      // å•æ‰“æ¨¡å¼ - ç§»é™¤é€‰æ‰‹æ•°é‡é™åˆ¶
      // åˆ‡æ¢é€‰æ‹©çŠ¶æ€?      let newSelectedPlayers = [...selectedPlayers];
      if (index !== -1) {
        // å–æ¶ˆé€‰æ‹©
        newSelectedPlayers.splice(index, 1);
      } else {
        // æ·»åŠ é€‰æ‹©
        newSelectedPlayers.push(player);
      }
      
      this.setData({
        selectedPlayers: newSelectedPlayers
      });
    }
  },
  
  /**
   * æ£€æŸ¥é€‰æ‰‹æ˜¯å¦è¢«é€‰ä¸­
   */
  isPlayerSelected: function(playerId) {
    return this.data.selectedPlayers.some(function(player) {
      return player.id === playerId;
    });
  },
  
  /**
   * ç¡®è®¤é€‰æ‰‹é€‰æ‹©
   */
  confirmPlayerSelection: function() {
    const { selectedPlayers, mode, tournamentType } = this.data;
    
    // æ£€æŸ¥é€‰æ‰‹æ•°é‡
    if (selectedPlayers.length < 2) {
      wx.showToast({
        title: 'è‡³å°‘éœ€è¦?åé€‰æ‰‹',
        icon: 'none'
      });
      return;
    }
    
    // å¦‚æœæ˜¯åŒæ‰“æ¨¡å¼ï¼Œæ£€æŸ¥é€‰æ‰‹æ•°é‡æ˜¯å¦ä¸ºå¶æ•?    if (mode === 'doubles' && selectedPlayers.length % 2 !== 0) {
      wx.showToast({
        title: 'åŒæ‰“æ¨¡å¼éœ€è¦å¶æ•°åé€‰æ‰‹',
        icon: 'none'
      });
      return;
    }

    // å¦‚æœæ˜¯åŒæ‰“æ¨¡å¼ï¼Œç»„ç»‡é€‰æ‰‹ä¸ºç»„å?    if (mode === 'doubles') {
      // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„ç”·å¥³é€‰æ‰‹ç»„æˆæ··åŒ
      const maleCount = selectedPlayers.filter(p => p.gender === 'male').length;
      const femaleCount = selectedPlayers.filter(p => p.gender === 'female').length;
      
      // æç¤ºæ€§åˆ«ç»„åˆæƒ…å†µ
      let pairsInfo = '';
      if (maleCount >= 2 && femaleCount >= 2) {
        pairsInfo = 'å°†ç»„æˆç”·åŒã€å¥³åŒå’Œæ··åŒç»„åˆ';
      } else if (maleCount >= 2) {
        pairsInfo = 'å°†ç»„æˆç”·åŒç»„å?;
      } else if (femaleCount >= 2) {
        pairsInfo = 'å°†ç»„æˆå¥³åŒç»„å?;
      } else if (maleCount > 0 && femaleCount > 0) {
        pairsInfo = 'å°†ç»„æˆæ··åŒç»„å?;
      }
      
      wx.showToast({
        title: pairsInfo,
        icon: 'none',
        duration: 2000
      });
    }
    
    // è®¡ç®—ç‘å£«è½®æ€»è½®æ¬¡ï¼ˆå¦‚æœæ˜¯ç‘å£«è½®ï¼?    if (tournamentType === 'swiss') {
      // ç‘å£«è½®é€šå¸¸ä¸ºlog2(n)å‘ä¸Šå–æ•´ï¼Œæœ€å¤šä¸è¶…è¿‡é€‰æ‰‹æ•°é‡-1
      const playerCount = mode === 'singles' ? selectedPlayers.length : selectedPlayers.length / 2;
      const totalRounds = Math.min(Math.ceil(Math.log2(playerCount)), playerCount - 1);
      
      this.setData({
        totalRounds: totalRounds
      });
      
      // åˆå§‹åŒ–é€‰æ‰‹æ’åï¼ˆæŒ‰ç…§åˆå§‹åˆ†æ•°æ’åºï¼‰
      const playerRankings = selectedPlayers.map(player => ({
        ...player,
        wins: 0,
        losses: 0,
        points: 0,
        opponents: []
      })).sort((a, b) => b.score - a.score);
      
      this.setData({
        playerRankings: playerRankings
      });
    }
    
    // ç”Ÿæˆæ¯”èµ›è¡¨æ ¼æ•°æ®
    this.generateMatchTable();
    
    this.setData({
      showPlayerSelectModal: false,
      isMatchStarted: true
    });
    
    // ä¿å­˜è¿›è¡Œä¸­çš„æ¯”èµ›
    this.saveOngoingMatch();
  },
  
  /**
   * ç”Ÿæˆæ¯”èµ›è¡¨æ ¼æ•°æ®
   */
  generateMatchTable: function() {
    const { selectedPlayers, mode, tournamentType, currentRound, playerRankings } = this.data;
    const matchTable = [];
    
    if (tournamentType === 'round_robin') {
      // å®Œå…¨å¾ªç¯èµ?    if (mode === 'singles') {
      // å•æ‰“æ¨¡å¼
      for (let i = 0; i < selectedPlayers.length; i++) {
        const row = {
          player: selectedPlayers[i],
          matches: []
        };
        
        for (let j = 0; j < selectedPlayers.length; j++) {
          if (i === j) {
            // è‡ªå·±å¯¹è‡ªå·±ï¼Œæ˜¾ç¤ºæ–œæ 
            row.matches.push({
              opponent: selectedPlayers[j],
              score: '/',
              isSelfMatch: true
            });
          } else {
            // æŸ¥æ‰¾æ˜¯å¦å·²æœ‰æ¯”èµ›è®°å½•
            const existingTable = this.data.matchTable || [];
            const existingRow = existingTable.find(r => r.player.id === selectedPlayers[i].id);
            const existingMatch = existingRow ? existingRow.matches.find(m => m.opponent.id === selectedPlayers[j].id) : null;
            
            row.matches.push({
              opponent: selectedPlayers[j],
              score: existingMatch ? existingMatch.score : '',
              id: `match_${selectedPlayers[i].id}_${selectedPlayers[j].id}`
            });
          }
        }
        
        matchTable.push(row);
      }
    } else {
      // åŒæ‰“æ¨¡å¼
      // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„åŒæ‰“ç»„åˆ
      const teams = [];
        
        // å…ˆå°†é€‰æ‰‹æŒ‰æ€§åˆ«åˆ†ç»„
        const malePlayers = selectedPlayers.filter(p => p.gender === 'male');
        const femalePlayers = selectedPlayers.filter(p => p.gender === 'female');
        
        // å°½å¯èƒ½ç»„æˆç”·å?        for (let i = 0; i < malePlayers.length - 1; i += 2) {
          if (i + 1 < malePlayers.length) {
            teams.push({
              id: `${malePlayers[i].id}_${malePlayers[i + 1].id}`,
              players: [malePlayers[i], malePlayers[i + 1]],
              name: `${malePlayers[i].name}/${malePlayers[i + 1].name}`,
              type: 'male' // æ ‡è®°ä¸ºç”·å?            });
          }
        }
        
        // å°½å¯èƒ½ç»„æˆå¥³å?        for (let i = 0; i < femalePlayers.length - 1; i += 2) {
          if (i + 1 < femalePlayers.length) {
            teams.push({
              id: `${femalePlayers[i].id}_${femalePlayers[i + 1].id}`,
              players: [femalePlayers[i], femalePlayers[i + 1]],
              name: `${femalePlayers[i].name}/${femalePlayers[i + 1].name}`,
              type: 'female' // æ ‡è®°ä¸ºå¥³å?            });
          }
        }
        
        // å‰©ä½™çš„ç”·é€‰æ‰‹å’Œå¥³é€‰æ‰‹ç»„æˆæ··åŒ
        const remainingMales = malePlayers.length % 2 === 1 ? [malePlayers[malePlayers.length - 1]] : [];
        const remainingFemales = femalePlayers.length % 2 === 1 ? [femalePlayers[femalePlayers.length - 1]] : [];
        
        const minCount = Math.min(remainingMales.length, remainingFemales.length);
        for (let i = 0; i < minCount; i++) {
        teams.push({
            id: `${remainingMales[i].id}_${remainingFemales[i].id}`,
            players: [remainingMales[i], remainingFemales[i]],
            name: `${remainingMales[i].name}/${remainingFemales[i].name}`,
            type: 'mixed' // æ ‡è®°ä¸ºæ··å?          });
        }
        
        // å¦‚æœè¿˜æœ‰å‰©ä½™é€‰æ‰‹ï¼Œä¸¤ä¸¤ç»„å?        const allRemaining = [...remainingMales.slice(minCount), ...remainingFemales.slice(minCount)];
        for (let i = 0; i < allRemaining.length - 1; i += 2) {
          if (i + 1 < allRemaining.length) {
            const type = allRemaining[i].gender === allRemaining[i + 1].gender ? 
                        (allRemaining[i].gender === 'male' ? 'male' : 'female') : 'mixed';
            teams.push({
              id: `${allRemaining[i].id}_${allRemaining[i + 1].id}`,
              players: [allRemaining[i], allRemaining[i + 1]],
              name: `${allRemaining[i].name}/${allRemaining[i + 1].name}`,
              type: type
            });
          }
        }
      
      for (let i = 0; i < teams.length; i++) {
        const row = {
          team: teams[i],
          matches: []
        };
        
        for (let j = 0; j < teams.length; j++) {
          if (i === j) {
            // è‡ªå·±å¯¹è‡ªå·±ï¼Œæ˜¾ç¤ºæ–œæ 
            row.matches.push({
              opponent: teams[j],
              score: '/',
              isSelfMatch: true
            });
          } else {
            // æŸ¥æ‰¾æ˜¯å¦å·²æœ‰æ¯”èµ›è®°å½•
            const existingTable = this.data.matchTable || [];
            const existingRow = existingTable.find(r => r.team && r.team.id === teams[i].id);
            const existingMatch = existingRow ? existingRow.matches.find(m => m.opponent.id === teams[j].id) : null;
            
            row.matches.push({
              opponent: teams[j],
              score: existingMatch ? existingMatch.score : '',
              id: `match_${teams[i].id}_${teams[j].id}`
            });
          }
        }
        
        matchTable.push(row);
        }
      }
    } else {
      // ç‘å£«è½®æ¯”èµ?      if (mode === 'singles') {
        // å•æ‰“æ¨¡å¼
        if (currentRound === 1) {
          // ç¬¬ä¸€è½®æŒ‰ç…§åˆå§‹æ’åé…å¯¹ï¼š1 vs n/2+1, 2 vs n/2+2, ...
          const n = selectedPlayers.length;
          const halfN = Math.ceil(n / 2);
          
          // ç¡®ä¿æ‰€æœ‰é€‰æ‰‹éƒ½èƒ½å‚ä¸æ¯”èµ›
          for (let i = 0; i < halfN; i++) {
            if (i + halfN < n) {
              // æ­£å¸¸é…å¯¹
              const match = {
                round: 1,
                player1: selectedPlayers[i],
                player2: selectedPlayers[i + halfN],
                score: '',
                winner: null
              };
              
              matchTable.push(match);
            } else if (i < n) {
              // å¦‚æœé€‰æ‰‹æ•°é‡ä¸ºå¥‡æ•°ï¼Œæœ€åä¸€åé€‰æ‰‹è½®ç©ºæˆ–å®‰æ’ç‰¹æ®Šæ¯”èµ?              console.log("é€‰æ‰‹æ•°é‡ä¸ºå¥‡æ•°ï¼Œæœ€åä¸€åé€‰æ‰‹è½®ç©º");
              // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ è½®ç©ºé€»è¾‘
            }
          }
        } else {
          // åç»­è½®æ¬¡æŒ‰ç…§å½“å‰æ’åé…å¯¹
          // è¿™é‡Œç®€å•å®ç°ï¼Œå®é™…ç‘å£«è½®æœ‰æ›´å¤æ‚çš„é…å¯¹è§„åˆ™
          const availablePlayers = [...playerRankings];
          
          while (availablePlayers.length >= 2) {
            const player1 = availablePlayers.shift();
            
            // æ‰¾åˆ°æœªæ›¾å¯¹é˜µè¿‡çš„å¯¹æ‰‹
            let opponentIndex = -1;
            for (let i = 0; i < availablePlayers.length; i++) {
              if (!player1.opponents.includes(availablePlayers[i].id)) {
                opponentIndex = i;
                break;
              }
            }
            
            // å¦‚æœæ‰¾ä¸åˆ°æœªæ›¾å¯¹é˜µè¿‡çš„å¯¹æ‰‹ï¼Œå°±é€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨çš„å¯¹æ‰‹
            if (opponentIndex === -1 && availablePlayers.length > 0) {
              opponentIndex = 0;
            }
            
            if (opponentIndex !== -1) {
              const player2 = availablePlayers.splice(opponentIndex, 1)[0];
              
              const match = {
                round: currentRound,
                player1: player1,
                player2: player2,
                score: '',
                winner: null
              };
              
              matchTable.push(match);
            }
          }
        }
      } else {
        // åŒæ‰“æ¨¡å¼
        if (currentRound === 1) {
          // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„åŒæ‰“ç»„åˆ
          const teams = [];
          for (let i = 0; i < selectedPlayers.length; i += 2) {
            if (i + 1 < selectedPlayers.length) {
              teams.push({
                id: `${selectedPlayers[i].id}_${selectedPlayers[i + 1].id}`,
                players: [selectedPlayers[i], selectedPlayers[i + 1]],
                name: `${selectedPlayers[i].name}/${selectedPlayers[i + 1].name}`,
                wins: 0,
                losses: 0,
                points: 0,
                opponents: []
              });
            }
          }

          // ä¿å­˜é˜Ÿä¼ä¿¡æ¯åˆ°playerRankings
          this.setData({
            playerRankings: teams
          });
          
          // ç¬¬ä¸€è½®æŒ‰ç…§é˜Ÿä¼æ•°é‡é…å¯?          const n = teams.length;
          const halfN = Math.ceil(n / 2);
          
          // ç¡®ä¿æ‰€æœ‰é˜Ÿä¼éƒ½èƒ½å‚ä¸æ¯”èµ?          for (let i = 0; i < halfN; i++) {
            if (i + halfN < n) {
              // æ­£å¸¸é…å¯¹
              const match = {
                round: 1,
                team1: teams[i],
                team2: teams[i + halfN],
                score: '',
                winner: null
              };
              
              matchTable.push(match);
            } else if (i < n) {
              // å¦‚æœé˜Ÿä¼æ•°é‡ä¸ºå¥‡æ•°ï¼Œæœ€åä¸€æ”¯é˜Ÿä¼è½®ç©ºæˆ–å®‰æ’ç‰¹æ®Šæ¯”èµ›
              console.log("é˜Ÿä¼æ•°é‡ä¸ºå¥‡æ•°ï¼Œæœ€åä¸€æ”¯é˜Ÿä¼è½®ç©?);
              // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ è½®ç©ºé€»è¾‘
            }
          }
        } else {
          // åç»­è½®æ¬¡æŒ‰ç…§å½“å‰æ’åé…å¯¹
          // è¿™é‡Œç®€å•å®ç°ï¼Œå®é™…ç‘å£«è½®æœ‰æ›´å¤æ‚çš„é…å¯¹è§„åˆ™
          const availableTeams = [...this.data.playerRankings];
          
          while (availableTeams.length >= 2) {
            const team1 = availableTeams.shift();
            
            // æ‰¾åˆ°æœªæ›¾å¯¹é˜µè¿‡çš„å¯¹æ‰‹
            let opponentIndex = -1;
            for (let i = 0; i < availableTeams.length; i++) {
              if (!team1.opponents.includes(availableTeams[i].id)) {
                opponentIndex = i;
                break;
              }
            }
            
            // å¦‚æœæ‰¾ä¸åˆ°æœªæ›¾å¯¹é˜µè¿‡çš„å¯¹æ‰‹ï¼Œå°±é€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨çš„å¯¹æ‰‹
            if (opponentIndex === -1 && availableTeams.length > 0) {
              opponentIndex = 0;
            }
            
            if (opponentIndex !== -1) {
              const team2 = availableTeams.splice(opponentIndex, 1)[0];
              
              const match = {
                round: currentRound,
                team1: team1,
                team2: team2,
                score: '',
                winner: null
              };
              
              matchTable.push(match);
            }
          }
        }
      }
    }
    
    this.setData({
      matchTable: matchTable
    });
  },
  
  /**
   * ä¿å­˜è¿›è¡Œä¸­çš„æ¯”èµ›
   */
  saveOngoingMatch: function() {
    const { selectedPlayers, matchTable, mode, tournamentType, currentRound, totalRounds, playerRankings } = this.data;
    
    const storageKey = tournamentType === 'swiss' ? 'ongoingSwissMatch' : 'ongoingRoundRobinMatch';
    
    // å¦‚æœæ˜¯ç‘å£«è½®ï¼Œä¿ç•™ä¹‹å‰çš„æ‰€æœ‰æ¯”èµ›è®°å½?    if (tournamentType === 'swiss') {
      const ongoingMatch = wx.getStorageSync(storageKey) || {};
      const allMatches = ongoingMatch.allMatches || [];
      
      wx.setStorageSync(storageKey, {
        mode: mode,
        tournamentType: tournamentType,
        players: selectedPlayers,
        matchTable: matchTable,
        currentRound: currentRound,
        totalRounds: totalRounds,
        playerRankings: playerRankings,
        allMatches: allMatches, // ä¿å­˜æ‰€æœ‰è½®æ¬¡çš„æ¯”èµ›
        updateTime: new Date().toISOString()
      });
    } else {
      wx.setStorageSync(storageKey, {
        mode: mode,
        tournamentType: tournamentType,
        players: selectedPlayers,
        matchTable: matchTable,
        currentRound: currentRound,
        totalRounds: totalRounds,
        playerRankings: playerRankings,
        updateTime: new Date().toISOString()
      });
    }
  },
  
  /**
   * è¾“å…¥æ¯”åˆ†
   */
  inputScore: function(e) {
    const { row, col } = e.currentTarget.dataset;
    // è·å–åˆ†æ•°ï¼Œä¼˜å…ˆä»dataset.scoreè·å–ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä»detail.valueè·å–
    const score = e.currentTarget.dataset.score || e.detail.value;
    
    // æ›´æ–°æ¯”åˆ†
    const matchTable = [...this.data.matchTable];
    matchTable[row].matches[col].score = score;
    
    // åŒæ—¶æ›´æ–°å¯¹åº”çš„åå‘æ¯”åˆ?    const player1 = matchTable[row].player || matchTable[row].team;
    const player2 = matchTable[row].matches[col].opponent;
    
    const reverseRow = matchTable.findIndex(r => 
      (r.player && r.player.id === player2.id) || 
      (r.team && r.team.id === player2.id)
    );
    
    const reverseCol = matchTable[reverseRow].matches.findIndex(m => 
      (m.opponent.id === player1.id)
    );
    
    matchTable[reverseRow].matches[reverseCol].score = score;
    
    this.setData({
      matchTable: matchTable
    });
    
    // ä¿å­˜è¿›è¡Œä¸­çš„æ¯”èµ›
    this.saveOngoingMatch();
  },
  
  /**
   * è¾“å…¥ç‘å£«è½®æ¯”èµ›æ¯”åˆ?   */
  inputSwissScore: function(e) {
    const matchIndex = e.currentTarget.dataset.matchIndex;
    const score = e.detail.value;
    
    // æ›´æ–°æ¯”åˆ†
    const matchTable = [...this.data.matchTable];
    matchTable[matchIndex].score = score;
    
    // è§£ææ¯”åˆ†
    const scores = score.split(':');
    if (scores.length === 2) {
      const leftScore = parseInt(scores[0]);
      const rightScore = parseInt(scores[1]);
      
      if (!isNaN(leftScore) && !isNaN(rightScore)) {
        if (leftScore > rightScore) {
          matchTable[matchIndex].winner = 'player1';
        } else if (rightScore > leftScore) {
          matchTable[matchIndex].winner = 'player2';
        } else {
          matchTable[matchIndex].winner = 'tie';
        }
      }
    }
    
    this.setData({
      matchTable: matchTable
    });
    
    // ä¿å­˜è¿›è¡Œä¸­çš„æ¯”èµ›
    this.saveOngoingMatch();
  },
  
  /**
   * è¿›å…¥ä¸‹ä¸€è½?   */
  nextRound: function() {
    const { matchTable, currentRound, totalRounds, mode } = this.data;
    
    // æ£€æŸ¥å½“å‰è½®æ¬¡æ˜¯å¦æ‰€æœ‰æ¯”èµ›éƒ½å·²å®Œæˆ?    const allMatchesCompleted = matchTable.every(match => match.winner);
    
    if (!allMatchesCompleted) {
      wx.showModal({
        title: 'æœªå®Œæˆæ¯”èµ?,
        content: 'å½“å‰è½®æ¬¡è¿˜æœ‰æœªå®Œæˆçš„æ¯”èµ›ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ',
        success: (res) => {
          if (res.confirm) {
            this.processCurrentRound();
          }
        }
      });
    } else {
      this.processCurrentRound();
    }
  },
  
  /**
   * å¤„ç†å½“å‰è½®æ¬¡ç»“æœå¹¶è¿›å…¥ä¸‹ä¸€è½?   */
  processCurrentRound: function() {
    const { matchTable, currentRound, mode, playerRankings } = this.data;
    
    // æ›´æ–°é€‰æ‰‹æ’å
    const updatedRankings = [...playerRankings];
    
    // å¤„ç†æœ¬è½®æ¯”èµ›ç»“æœ
    for (const match of matchTable) {
      // è·³è¿‡æ²¡æœ‰ç»“æœçš„æ¯”èµ?      if (!match.winner) continue;
      
      if (mode === 'singles') {
        // å•æ‰“æ¨¡å¼
        const player1Index = updatedRankings.findIndex(p => p.id === match.player1.id);
        const player2Index = updatedRankings.findIndex(p => p.id === match.player2.id);
        
        if (player1Index !== -1 && player2Index !== -1) {
          // è®°å½•å¯¹æ‰‹
          updatedRankings[player1Index].opponents.push(match.player2.id);
          updatedRankings[player2Index].opponents.push(match.player1.id);
          
          // æ›´æ–°èƒœè´Ÿåœºæ¬¡å’Œç§¯åˆ?          if (match.winner === 'player1') {
            updatedRankings[player1Index].wins++;
            updatedRankings[player1Index].points += 2;
            updatedRankings[player2Index].losses++;
          } else if (match.winner === 'player2') {
            updatedRankings[player2Index].wins++;
            updatedRankings[player2Index].points += 2;
            updatedRankings[player1Index].losses++;
          } else if (match.winner === 'tie') {
            updatedRankings[player1Index].points += 1;
            updatedRankings[player2Index].points += 1;
          }
        }
      } else {
        // åŒæ‰“æ¨¡å¼
        const team1Index = updatedRankings.findIndex(t => t.id === match.team1.id);
        const team2Index = updatedRankings.findIndex(t => t.id === match.team2.id);
        
        if (team1Index !== -1 && team2Index !== -1) {
          // è®°å½•å¯¹æ‰‹
          updatedRankings[team1Index].opponents.push(match.team2.id);
          updatedRankings[team2Index].opponents.push(match.team1.id);
          
          // æ›´æ–°èƒœè´Ÿåœºæ¬¡å’Œç§¯åˆ?          if (match.winner === 'player1') {
            updatedRankings[team1Index].wins++;
            updatedRankings[team1Index].points += 2;
            updatedRankings[team2Index].losses++;
          } else if (match.winner === 'player2') {
            updatedRankings[team2Index].wins++;
            updatedRankings[team2Index].points += 2;
            updatedRankings[team1Index].losses++;
          } else if (match.winner === 'tie') {
            updatedRankings[team1Index].points += 1;
            updatedRankings[team2Index].points += 1;
          }
        }
      }
    }
    
    // æŒ‰ç§¯åˆ†æ’åº?    updatedRankings.sort((a, b) => {
      if (a.points !== b.points) return b.points - a.points;
      if (a.wins !== b.wins) return b.wins - a.wins;
      return 0;
    });
    
    // ä¿å­˜å½“å‰è½®æ¬¡çš„æ¯”èµ›è®°å½•åˆ°æœ¬åœ°å­˜å‚¨
    const ongoingMatch = wx.getStorageSync('ongoingSwissMatch') || {};
    const allMatches = ongoingMatch.allMatches || [];
    
    // å°†å½“å‰è½®æ¬¡çš„æ¯”èµ›æ·»åŠ åˆ°å†å²è®°å½?    const currentRoundMatches = matchTable.filter(match => match.winner);
    allMatches.push(...currentRoundMatches);
    
    // æ›´æ–°æœ¬åœ°å­˜å‚¨
    ongoingMatch.allMatches = allMatches;
    wx.setStorageSync('ongoingSwissMatch', ongoingMatch);
    
    // è¿›å…¥ä¸‹ä¸€è½?    this.setData({
      currentRound: currentRound + 1,
      playerRankings: updatedRankings
    });
    
    // ç”Ÿæˆä¸‹ä¸€è½®æ¯”èµ?    this.generateMatchTable();
    
    // ä¿å­˜è¿›è¡Œä¸­çš„æ¯”èµ›
    this.saveOngoingMatch();
  },
  
  /**
   * ç»“æŸæ¯”èµ›
   */
  endMatch: function() {
    const that = this;
    wx.showModal({
      title: 'ç¡®è®¤ç»“æŸæ¯”èµ›',
      content: 'ç»“æŸæ¯”èµ›åå°†æ— æ³•ç»§ç»­è®°åˆ†ï¼Œç¡®å®šè¦ç»“æŸå—ï¼Ÿ',
      success: function(res) {
        if (res.confirm) {
          // å¤„ç†æ¯”èµ›ç»“æœ
          that.processMatchResults();
          
          // æ¸…é™¤è¿›è¡Œä¸­çš„æ¯”èµ›
          const storageKey = that.data.tournamentType === 'swiss' ? 'ongoingSwissMatch' : 'ongoingRoundRobinMatch';
          wx.removeStorageSync(storageKey);
          
          // å¦‚æœæ˜¯ç‘å£«è½®æ¯”èµ›ï¼Œæ˜¾ç¤ºæ’åç»“æ?          if (that.data.tournamentType === 'swiss') {
            that.showRankingModal();
          } else {
            // ç›´æ¥è¿”å›ä¸»é¡µ
            wx.reLaunch({
              url: '/pages/index/index'
            });
          }
        }
      }
    });
  },
  
  /**
   * æ˜¾ç¤ºæ’åç»“æœå¼¹çª—
   */
  showRankingModal: function() {
    // ç¡®ä¿æ’åæ˜¯æŒ‰ç…§ç§¯åˆ†å’Œèƒœåœºæ’åºçš?    const playerRankings = [...this.data.playerRankings];
    playerRankings.sort((a, b) => {
      if (a.points !== b.points) return b.points - a.points;
      if (a.wins !== b.wins) return b.wins - a.wins;
      return 0;
    });
    
    this.setData({
      showRankingModal: true,
      playerRankings: playerRankings
    });
  },
  
  /**
   * éšè—æ’åç»“æœå¼¹çª—
   */
  hideRankingModal: function() {
    this.setData({
      showRankingModal: false
    });
  },
  
  /**
   * ç¡®è®¤æ’åç»“æœ
   */
  confirmRanking: function() {
    this.hideRankingModal();
    
    // è¿”å›ä¸»é¡µ
    wx.reLaunch({
      url: '/pages/index/index'
    });
  },
  
  /**
   * å¤„ç†æ¯”èµ›ç»“æœ
   */
  processMatchResults: function() {
    const { matchTable, mode, tournamentType, currentRound, playerRankings } = this.data;
    const matchHistory = [];
    
    // æ·»åŠ æ£€æŸ¥ä¸´æ—¶é€‰æ‰‹çš„è¾…åŠ©å‡½æ•?    const hasTemporaryPlayer = (players) => {
      return players.some(player => player.isTemporary === true);
    };
    
    if (tournamentType === 'round_robin') {
      // å®Œå…¨å¾ªç¯èµ?    // éå†æ¯”èµ›è¡¨æ ¼ï¼Œæå–æœ‰æ•ˆæ¯”èµ›ç»“æ?    for (let i = 0; i < matchTable.length; i++) {
      for (let j = 0; j < matchTable[i].matches.length; j++) {
        const match = matchTable[i].matches[j];
        
        // è·³è¿‡è‡ªå·±å¯¹è‡ªå·±çš„æ¯”èµ›å’Œæ²¡æœ‰æ¯”åˆ†çš„æ¯”èµ›
        if (match.score === '-' || match.score === '') continue;
        
        // è·³è¿‡å·²å¤„ç†è¿‡çš„æ¯”èµ›ï¼ˆé¿å…é‡å¤ï¼?        if (i > j) continue;
        
        // è§£ææ¯”åˆ†
        const scores = match.score.split(':');
        if (scores.length !== 2) continue;
        
        const leftScore = parseInt(scores[0]);
        const rightScore = parseInt(scores[1]);
        
        if (isNaN(leftScore) || isNaN(rightScore)) continue;
        
        // åˆ›å»ºæ¯”èµ›è®°å½•
        let matchRecord;
        let leftTeamPlayers, rightTeamPlayers;
        
        if (mode === 'singles') {
          leftTeamPlayers = [matchTable[i].player];
          rightTeamPlayers = [match.opponent];
          
          matchRecord = {
            id: Date.now().toString() + '_' + i + '_' + j,
            date: new Date().toISOString(),
            leftTeam: leftTeamPlayers,
            rightTeam: rightTeamPlayers,
            leftScore: leftScore,
            rightScore: rightScore,
            winner: leftScore > rightScore ? 'left' : 'right'
          };
        } else {
          leftTeamPlayers = matchTable[i].team.players;
          rightTeamPlayers = match.opponent.players;
          
          matchRecord = {
            id: Date.now().toString() + '_' + i + '_' + j,
            date: new Date().toISOString(),
            leftTeam: leftTeamPlayers,
            rightTeam: rightTeamPlayers,
            leftScore: leftScore,
            rightScore: rightScore,
            winner: leftScore > rightScore ? 'left' : 'right'
            };
          }
          
          // æ£€æŸ¥æ˜¯å¦åŒ…å«ä¸´æ—¶é€‰æ‰‹ï¼Œå¦‚æœåŒ…å«åˆ™ä¸è®°å½?          if (hasTemporaryPlayer(leftTeamPlayers) || hasTemporaryPlayer(rightTeamPlayers)) {
            continue;
          }
          
          // ä½¿ç”¨ELOç³»ç»Ÿæ›´æ–°ç§¯åˆ†
          const scoreChanges = app.submitMatch(matchRecord);
          
          // å°†ç§¯åˆ†å˜åŒ–å€¼æ·»åŠ åˆ°æ¯”èµ›è®°å½•ä¸?          matchRecord.winnerChange = scoreChanges.winnerChange;
          matchRecord.loserChange = scoreChanges.loserChange;
          
          // æ·»åŠ åˆ°å†å²è®°å½?          matchHistory.push(matchRecord);
        }
      }
    } else {
      // ç‘å£«è½®æ¯”èµ?      // è·å–è¿›è¡Œä¸­çš„ç‘å£«è½®æ¯”èµ›æ•°æ®ï¼ŒåŒ…æ‹¬æ‰€æœ‰è½®æ¬¡çš„æ¯”èµ›
      const ongoingMatch = wx.getStorageSync('ongoingSwissMatch');
      const allRoundMatches = ongoingMatch ? ongoingMatch.matchTable || [] : [];
      
      // å¤„ç†æ‰€æœ‰è½®æ¬¡çš„æ¯”èµ›
      for (const match of allRoundMatches) {
        // è·³è¿‡æ²¡æœ‰æ¯”åˆ†çš„æ¯”èµ?        if (!match.score || !match.winner) continue;
        
        // è§£ææ¯”åˆ†
        const scores = match.score.split(':');
        if (scores.length !== 2) continue;
        
        const leftScore = parseInt(scores[0]);
        const rightScore = parseInt(scores[1]);
        
        if (isNaN(leftScore) || isNaN(rightScore)) continue;
        
        // åˆ›å»ºæ¯”èµ›è®°å½•
        let matchRecord;
        let leftTeamPlayers, rightTeamPlayers;
        const matchRound = match.round || 1; // ç¡®ä¿æœ‰è½®æ¬¡ä¿¡æ?        
        if (mode === 'singles') {
          leftTeamPlayers = [match.player1];
          rightTeamPlayers = [match.player2];
          
          matchRecord = {
            id: Date.now().toString() + '_' + match.player1.id + '_' + match.player2.id + '_round' + matchRound,
            date: new Date().toISOString(),
            leftTeam: leftTeamPlayers,
            rightTeam: rightTeamPlayers,
            leftScore: leftScore,
            rightScore: rightScore,
            winner: match.winner === 'player1' ? 'left' : 'right',
            round: matchRound // æ·»åŠ è½®æ¬¡ä¿¡æ¯
          };
        } else {
          leftTeamPlayers = match.team1.players;
          rightTeamPlayers = match.team2.players;
          
          matchRecord = {
            id: Date.now().toString() + '_' + match.team1.id + '_' + match.team2.id + '_round' + matchRound,
            date: new Date().toISOString(),
            leftTeam: leftTeamPlayers,
            rightTeam: rightTeamPlayers,
            leftScore: leftScore,
            rightScore: rightScore,
            winner: match.winner === 'player1' ? 'left' : 'right',
            round: matchRound // æ·»åŠ è½®æ¬¡ä¿¡æ¯
          };
        }
        
        // æ£€æŸ¥æ˜¯å¦åŒ…å«ä¸´æ—¶é€‰æ‰‹ï¼Œå¦‚æœåŒ…å«åˆ™ä¸è®°å½?        if (hasTemporaryPlayer(leftTeamPlayers) || hasTemporaryPlayer(rightTeamPlayers)) {
          continue;
        }
        
        // ä½¿ç”¨ELOç³»ç»Ÿæ›´æ–°ç§¯åˆ†
        const scoreChanges = app.submitMatch(matchRecord);
        
        // å°†ç§¯åˆ†å˜åŒ–å€¼æ·»åŠ åˆ°æ¯”èµ›è®°å½•ä¸?        matchRecord.winnerChange = scoreChanges.winnerChange;
        matchRecord.loserChange = scoreChanges.loserChange;
        
        // æ·»åŠ åˆ°å†å²è®°å½?        matchHistory.push(matchRecord);
      }
    }
    
    // æ›´æ–°å…¨å±€æ¯”èµ›è®°å½•
    const allMatchHistory = [...app.globalData.matchHistory, ...matchHistory];
    app.globalData.matchHistory = allMatchHistory;
    
    // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚?    wx.setStorageSync('matchHistory', allMatchHistory);
  },

  /**
   * æ˜¾ç¤ºæ·»åŠ ä¸´æ—¶é€‰æ‰‹å¼¹çª—
   */
  showAddTempPlayerModal: function() {
    this.setData({
      showAddTempPlayerModal: true,
      tempPlayerName: '',
      tempPlayerGender: 'male'
    });
  },

  /**
   * éšè—æ·»åŠ ä¸´æ—¶é€‰æ‰‹å¼¹çª—
   */
  hideAddTempPlayerModal: function() {
    this.setData({
      showAddTempPlayerModal: false
    });
  },

  /**
   * ç›‘å¬ä¸´æ—¶é€‰æ‰‹å§“åè¾“å…¥
   */
  onTempPlayerNameInput: function(e) {
    this.setData({
      tempPlayerName: e.detail.value
    });
  },

  /**
   * é€‰æ‹©ä¸´æ—¶é€‰æ‰‹æ€§åˆ«
   */
  selectTempPlayerGender: function(e) {
    const gender = e.currentTarget.dataset.gender;
    this.setData({
      tempPlayerGender: gender
    });
  },

  /**
   * æ·»åŠ ä¸´æ—¶é€‰æ‰‹
   */
  addTempPlayer: function() {
    const { tempPlayerName, tempPlayerGender, players } = this.data;
    
    // éªŒè¯å§“å
    if (!tempPlayerName.trim()) {
      wx.showToast({
        title: 'è¯·è¾“å…¥é€‰æ‰‹å§“å',
        icon: 'none'
      });
      return;
    }
    
    // æ£€æŸ¥åç§°æ˜¯å¦é‡å¤?    const nameExists = players.some(player => player.name === tempPlayerName);
    
    // åˆ›å»ºä¸´æ—¶é€‰æ‰‹å¯¹è±¡ï¼Œæ·»åŠ?ä¸?æ ‡è¯†
    const displayName = nameExists ? `${tempPlayerName}(ä¸?` : `${tempPlayerName}(ä¸?`;
    
    const tempPlayer = {
      id: 'temp_' + Date.now(),
      name: displayName,
      gender: tempPlayerGender,
      score: 1000, // é»˜è®¤åˆ†æ•°
      avatarUrl: tempPlayerGender === 'female' ? '/images/default-avatar-female.png' : '/images/default-avatar.png',
      isTemporary: true
    };
    
    // æ·»åŠ åˆ°é€‰æ‰‹åˆ—è¡¨å’Œå·²é€‰æ‹©åˆ—è¡¨
    const updatedPlayers = [...this.data.players, tempPlayer];
    const updatedSelectedPlayers = [...this.data.selectedPlayers, tempPlayer];
    
    this.setData({
      players: updatedPlayers,
      selectedPlayers: updatedSelectedPlayers,
      showAddTempPlayerModal: false
    });
    
    wx.showToast({
      title: 'ä¸´æ—¶é€‰æ‰‹å·²æ·»åŠ?,
      icon: 'success'
    });
  },

  /**
   * æ˜¾ç¤ºæ¯”åˆ†è¾“å…¥å¼¹çª—
   */
  showScoreInputModal: function(e) {
    const row = e.currentTarget.dataset.row;
    const col = e.currentTarget.dataset.col;
    const matchIndex = e.currentTarget.dataset.matchIndex;
    
    // åˆ¤æ–­æ˜¯å¦ä¸ºç‘å£«è½®æ¯”èµ›
    if (this.data.tournamentType === 'swiss') {
      // è·å–ç‘å£«è½®æ¯”èµ›æ•°æ?      const match = this.data.matchTable[matchIndex];
      const team = this.data.mode === 'singles' ? match.player1 : match.team1;
      const opponent = this.data.mode === 'singles' ? match.player2 : match.team2;
      
      // è§£æå·²æœ‰çš„æ¯”åˆ?      let teamScore = '';
      let opponentScore = '';
      if (match.score && match.score.includes(':')) {
        const scores = match.score.split(':');
        teamScore = scores[0];
        opponentScore = scores[1];
      }
      
      this.setData({
        showScoreInputModal: true,
        currentMatch: {
          matchIndex: matchIndex,
          team: team,
          opponent: opponent,
          isSwiss: true
        },
        teamScore: teamScore,
        opponentScore: opponentScore,
        activeScoreInput: 'team' // é»˜è®¤æ¿€æ´»é˜Ÿä¼åˆ†æ•°è¾“å…¥æ¡†
      });
    } else {
      // è·å–å¯¹åº”çš„æ¯”èµ›æ•°æ?      const match = this.data.matchTable[row].matches[col];
      const team = this.data.matchTable[row].player || this.data.matchTable[row].team;
      const opponent = match.opponent;
      
      // è§£æå·²æœ‰çš„æ¯”åˆ?      let teamScore = '';
      let opponentScore = '';
      if (match.score && match.score.includes(':')) {
        const scores = match.score.split(':');
        teamScore = scores[0];
        opponentScore = scores[1];
      }
      
      this.setData({
        showScoreInputModal: true,
        currentMatch: {
          row: row,
          col: col,
          team: team,
          opponent: opponent,
          isSwiss: false
        },
        teamScore: teamScore,
        opponentScore: opponentScore,
        activeScoreInput: 'team' // é»˜è®¤æ¿€æ´»é˜Ÿä¼åˆ†æ•°è¾“å…¥æ¡†
      });
    }
  },
  
  /**
   * éšè—æ¯”åˆ†è¾“å…¥å¼¹çª—
   */
  hideScoreInputModal: function() {
    this.setData({
      showScoreInputModal: false,
      currentMatch: null,
      teamScore: '',
      opponentScore: ''
    });
  },
  
  /**
   * å¤„ç†é˜Ÿä¼åˆ†æ•°è¾“å…¥
   */
  onTeamScoreInput: function(e) {
    this.setData({
      teamScore: e.detail.value
    });
  },
  
  /**
   * å¤„ç†å¯¹æ‰‹åˆ†æ•°è¾“å…¥
   */
  onOpponentScoreInput: function(e) {
    this.setData({
      opponentScore: e.detail.value
    });
  },
  
  /**
   * è®¾ç½®å¿«æ·åˆ†æ•°
   */
  setQuickScore: function(e) {
    const { team, opponent } = e.currentTarget.dataset;
    
    this.setData({
      teamScore: team,
      opponentScore: opponent
    });
  },
  
  /**
   * ç¡®è®¤æ¯”åˆ†
   */
  confirmScore: function() {
    const { currentMatch, teamScore, opponentScore } = this.data;
    
    if (!teamScore && !opponentScore) {
      wx.showToast({
        title: 'è¯·è¾“å…¥æ¯”åˆ?,
        icon: 'none'
      });
      return;
    }
    
    if (currentMatch.isSwiss) {
      // å¤„ç†ç‘å£«è½®æ¯”èµ›çš„æ¯”åˆ†
      const score = teamScore + ':' + opponentScore;
      
      // æ›´æ–°æ¯”åˆ†
      const matchTable = [...this.data.matchTable];
      matchTable[currentMatch.matchIndex].score = score;
      
      // è§£ææ¯”åˆ†
      const leftScore = parseInt(teamScore);
      const rightScore = parseInt(opponentScore);
      
      if (!isNaN(leftScore) && !isNaN(rightScore)) {
        if (leftScore > rightScore) {
          matchTable[currentMatch.matchIndex].winner = 'player1';
        } else if (rightScore > leftScore) {
          matchTable[currentMatch.matchIndex].winner = 'player2';
        } else {
          matchTable[currentMatch.matchIndex].winner = 'tie';
        }
      }
      
      this.setData({
        matchTable: matchTable
      });
    } else {
      // è°ƒç”¨åŸæœ‰çš„inputScoreæ–¹æ³•å¤„ç†åˆ†æ•°
      this.inputScore({
        currentTarget: {
          dataset: {
            row: currentMatch.row,
            col: currentMatch.col,
            score: teamScore + ':' + opponentScore
          }
        }
      });
    }
    
    // ä¿å­˜è¿›è¡Œä¸­çš„æ¯”èµ›
    this.saveOngoingMatch();
    
    // éšè—å¼¹çª—
    this.hideScoreInputModal();
  },

  /**
   * æ¸…é™¤åŒæ‰“ç»„åˆ
   */
  clearTeam: function(e) {
    const index = e.currentTarget.dataset.index;
    const { selectedPlayers } = this.data;
    let newSelectedPlayers = [...selectedPlayers];
    
    if (index === 0) {
      // æ¸…é™¤ç¬¬ä¸€ç»?      newSelectedPlayers.splice(0, 2);
      // å¦‚æœè¿˜æœ‰ç¬¬äºŒç»„ï¼Œå°†å…¶ç§»åˆ°ç¬¬ä¸€ç»„ä½ç½?      if (newSelectedPlayers.length >= 2) {
        const team2 = newSelectedPlayers.splice(0, 2);
        newSelectedPlayers = team2.concat(newSelectedPlayers);
      }
    } else if (index === 1) {
      // æ¸…é™¤ç¬¬äºŒç»?      newSelectedPlayers.splice(2, 2);
    }
    
    this.setData({
      selectedPlayers: newSelectedPlayers
    });
  },

  /**
   * ç§»é™¤åŒæ‰“ç»„åˆ
   */
  removeDoublesTeam: function(e) {
    const index = e.currentTarget.dataset.index;
    const { selectedPlayers } = this.data;
    let newSelectedPlayers = [...selectedPlayers];
    
    // ç§»é™¤æŒ‡å®šç´¢å¼•å¤„çš„ä¸¤åé€‰æ‰‹
    newSelectedPlayers.splice(index, 2);
    
    this.setData({
      selectedPlayers: newSelectedPlayers
    });
  },

  /**
   * ä»å·²é€‰æ‹©åˆ—è¡¨ä¸­ç§»é™¤é€‰æ‰‹
   */
  removeSelectedPlayer: function(e) {
    const playerId = e.currentTarget.dataset.playerId;
    const selectedPlayers = this.data.selectedPlayers.filter(p => p.id !== playerId);
    
    this.setData({
      selectedPlayers: selectedPlayers
    });
  },

  /**
   * è®¾ç½®å½“å‰æ¿€æ´»çš„åˆ†æ•°è¾“å…¥æ¡?   */
  setActiveScoreInput: function(e) {
    const input = e.currentTarget.dataset.input;
    this.setData({
      activeScoreInput: input
    });
  },
  
  /**
   * è¾“å…¥æ•°å­—
   */
  inputNumber: function(e) {
    const number = e.currentTarget.dataset.number;
    const { activeScoreInput, teamScore, opponentScore } = this.data;
    
    if (activeScoreInput === 'team') {
      // è¾“å…¥é˜Ÿä¼åˆ†æ•°
      let newScore = teamScore === '' ? number : teamScore + number;
      // é™åˆ¶æœ€å¤§ä¸º99
      if (parseInt(newScore) <= 99) {
        this.setData({
          teamScore: newScore
        });
      }
    } else if (activeScoreInput === 'opponent') {
      // è¾“å…¥å¯¹æ‰‹åˆ†æ•°
      let newScore = opponentScore === '' ? number : opponentScore + number;
      // é™åˆ¶æœ€å¤§ä¸º99
      if (parseInt(newScore) <= 99) {
        this.setData({
          opponentScore: newScore
        });
      }
    }
  },
  
  /**
   * è¾“å…¥å¿«æ·æ•°å­—
   */
  inputQuickNumber: function(e) {
    const number = e.currentTarget.dataset.number;
    const { activeScoreInput } = this.data;
    
    if (activeScoreInput === 'team') {
      this.setData({
        teamScore: number
      });
    } else if (activeScoreInput === 'opponent') {
      this.setData({
        opponentScore: number
      });
    }
  },
  
  /**
   * æ¸…é™¤æ•°å­—
   */
  clearNumber: function() {
    const { activeScoreInput } = this.data;
    
    if (activeScoreInput === 'team') {
      this.setData({
        teamScore: ''
      });
    } else if (activeScoreInput === 'opponent') {
      this.setData({
        opponentScore: ''
      });
    }
  },
  
  /**
   * åˆ é™¤æ•°å­—
   */
  deleteNumber: function() {
    const { activeScoreInput, teamScore, opponentScore } = this.data;
    
    if (activeScoreInput === 'team' && teamScore.length > 0) {
      this.setData({
        teamScore: teamScore.slice(0, -1)
      });
    } else if (activeScoreInput === 'opponent' && opponentScore.length > 0) {
      this.setData({
        opponentScore: opponentScore.slice(0, -1)
      });
    }
  },
}); 
